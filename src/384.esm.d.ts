// Generated by dts-bundle-generator v8.1.2

/**
 * Assemble payload. This creates a single binary (wire) format
 * of an arbitrary set of (named) binary objects. os384 payloads
 * are always ArrayBuffer objects, and always start with a 4-byte
 * identifier 0xAABBBBAA (which is easy to spot in a hex editor).
 * @public
 */
export declare function assemblePayload(data: any): ArrayBuffer | null;
/**
 * Extract payload - this decodes from our binary (wire) format
 * to a JS object. This supports a wide range of objects.
 * @public
 */
export declare function extractPayload(value: ArrayBuffer): any;
/**
  * Basic (core) capability object in SB.
  *
  * Can initialize from various formats. If no starting point key is given,
  * it will "mint" a fresh key.
  *
  * If ``forcePrivate`` is true, will force SB384 to include private key; it
  * will throw an exception if the key is not private. If SB384 is used to mint,
  * then it's always private.
  *
  * The important "externally visible" formats are:
  *
  * - {@link SB384.userId}: unique hash ({@link SB384Hash}) of contents of
  *   public key, shorter format (256 bits, 43 x base62), cannot be used to
  *   reconstruct key, used to identify users (and channels)
  *
  * - {@link SB384.userPublicKey}: encodes core public key info ('x' and 'y' fields), as a
  *   base62 string (with a unique prefix). This is 'wire' format as well as
  *   human-readable.
  *
  * - userPrivateKey(): similar to public key format, adds the 'd' field
  *   information (embedded), from this format a full private key can be
  *   reconstructed.
  *
  * Like most SB classes, SB384 follows the "ready template" design pattern: the
  * object is immediately available upon creation, but isn't "ready" until it
  * says it's ready. See {@link Channel} example below. Getters will throw
  * exceptions if the object isn't sufficiently initialized. Also see Design
  * Note [4]_.
  *
  * @public
  */
export declare class SB384 {
	#private;
	sb384Ready: Promise<SB384>;
	static ReadyFlag: symbol;
	errorState: boolean;
	/**
	 * As a fundamental object, SB384 can be initialized from a number starting points:
	 *
	 * - No key provided: a new key pair is generated
	 *
	 * - A CryptoKey object: a key pair is generated from the CryptoKey
	 *
	 * - A JsonWebKey object: a key pair is generated from the provided JsonWebKey
	 *
	 * - A SBUserPublicKey object: a key pair is generated from the SBUserPublicKey
	 *
	 * - A SBUserPrivateKey object: a key pair is generated from the SBUserPrivateKey
	 *
	 * The 'forcePrivate' parameter is used to force the object to be private; if
	 * the key provided is inherently not private, an exception is thrown. This simplifies
	 * situation where it would only make sense if you're operating with a private key,
	 * and spares you from (sometimes convoluted) checks (eg what fields are present in
	 * a 'jwk' field etc).
	 */
	constructor(key?: CryptoKey | JsonWebKey | SBUserPublicKey | SBUserPrivateKey, forcePrivate?: boolean);
	get SB384ReadyFlag(): any;
	get ready(): Promise<SB384>;
	/** Returns true if this is a private key, otherwise false.
	 * Will throw an exception if the object is not ready. */
	get private(): boolean;
	/**
	 * Returns a unique identifier for external use, that will be unique
	 * for any class or object that uses SB384 as it's root.
	 *
	 * This is deterministic. Typical use case is to translate a user id
	 * into a {@link ChannelId} (eg the channel that any user id is inherently
	 * the owner of).
	 *
	 * The hash is base62 encoding of the SHA-384 hash of the public key.
	 *
	 */
	get hash(): SB384Hash;
	/**
	 * Similar to {@link SB384.hash}, but base32 encoded.
	 */
	get hashB32(): SB384Hash;
	get userId(): SB384Hash;
	/**
	 * This is the {@link ChannelId} corresponding to the user private key.
	 * (If user is owner of THIS channel, then this is same as channelid.)
	 */
	get ownerChannelId(): string;
	/** @type {CryptoKey} Private key (might not be present, in which case this will throw) */
	get privateKey(): CryptoKey;
	/** @type {CryptoKey} Signing key. */
	get signKey(): CryptoKey;
	/** @type {CryptoKey} Basic public key, always present. */
	get publicKey(): CryptoKey;
	/** @type {JsonWebKey} Exports private key in 'jwk' format. */
	get jwkPrivate(): JsonWebKey;
	/** @type {JsonWebKey} Exports public key in 'jwk' format. */
	get jwkPublic(): JsonWebKey;
	get ySign(): 0 | 1;
	/**
	 * Wire format of full (decodable) public key
	 * @type {SBUserPublicKey}
	 */
	get userPublicKey(): SBUserPublicKey;
	/**
	 * Wire format of full info of key (eg private key). Compressed.
	 */
	get userPrivateKey(): SBUserPrivateKey;
	/**
	 * Compressed and dehydrated, meaning, 'x' needs to come from another source
	 * (namely, derived from 'd').
	 */
	get userPrivateKeyDehydrated(): SBUserPrivateKey;
	/**
	 * Returns private key field 'd' as a binary ArrayBuffer.
	 */
	get binaryD(): ArrayBuffer;
	/**
	 * Convenience wrapper, returns a promise to new, valid SB384 private key.
	 * It's essentially short for:
	 *
	 * ```javascript
	 * const newKey = (await (new SB384()).ready).userPrivateKey
	 * ```
	 * @public
	 */
	static newPrivateKey(): Promise<SBUserPrivateKey>;
}
declare function importKey(format: KeyFormat, key: BufferSource | JsonWebKey, type: "ECDH" | "AES" | "PBKDF2", extractable: boolean, keyUsages: KeyUsage[]): Promise<CryptoKey>;
/** @internal */
export declare class MessageQueue<T> {
	private queue;
	private resolve;
	private reject;
	private closed;
	private error;
	enqueue(item: T): void;
	dequeue(): Promise<T | null>;
	isEmpty(): boolean;
	close(reason?: string): void;
	drain(reason?: string): Promise<void>;
}
/**
 * Channel 'descriptor'. Validator is {@link validate_ChannelHandle}.
 * @public
 */
export interface ChannelHandle {
	[SB_CHANNEL_HANDLE_SYMBOL]?: boolean;
	/** minimum info is the key */
	userPrivateKey: SBUserPrivateKey;
	/** if channelID is omitted, then the key will be treated as the Owner key
		(channelId is always derived from owner key) */
	channelId?: ChannelId;
	/** if channel server is omitted, will use default (global) server */
	channelServer?: string;
	/** server-side channel data; if missing the server can provide it; if the
		handle is meant to be 'completely stand-alone', it's good practice to
		include this */
	channelData?: SBChannelData;
}
/**
 * Validates 'ChannelHandle', throws if there's an issue
 * @public
 */
export declare function validate_ChannelHandle(data: ChannelHandle): ChannelHandle;
/**
 * Options for sending a message.
 * @public
 */
export interface MessageOptions {
	/** Time to live, see MessageTtl enum for how it translates to time. */
	ttl?: MessageTtl;
	/** Routed message (named recipient). Will be SBUserId but for convenience internally will convert from SBUserPublicKey. */
	sendTo?: SBUserId | SBUserPublicKey;
	/** 'i2' in ChannelMessage (Owner only) */
	subChannel?: string;
	protocol?: SBProtocol;
	/** if true, just send the string, no other processing */
	sendString?: boolean;
	/** Internal. Optional override of defaults (0 for no retries) */
	retries?: number;
}
/**
	 Index/number of seconds/string description of TTL values (0-15) for
	 messages and shards.

	 ```text
		 #    Seconds  Description
		 0          0  Ephemeral (not stored)
		 1             <reserved>
		 2             <reserved>
		 3         60  One minute (current minimum)
		 4        300  Five minutes
		 5       1800  Thirty minutes
		 6      14400  Four hours
		 7     129600  36 hours
		 8     864000  Ten days
		10             <reserved> (all 'reserved' future choices will be monotonically increasing)
		11             <reserved>
		12             <reserved>
		13             <reserved>
		14             <reserved>
		15   Infinity  Permastore, this is the default.
	  ```

	  Note that time periods above '8' (10 days) is largely TBD pending
	  finalization of what the storage server will prefer. As far as messages
	  are concerned, anything above '8' is 'very long'.

	  A few rules around messages and TTL (this list is not exhaustive):

	  - Currently only values 0, 3-8, and 15 are valid (15 is default).
	  - Routable messages (eg messages with a 'to' field) may not have ttl above '8'.
	  - TTL messages are never in storage shards; channel servers can chose to
		limit how many they will keep (on a per TTL category basis) regardless
		of time value (but at least last 1000).
	  - TTL messages are duplicated and available on 'main' channel ('i2')
		'____' as well as on subchannels '___3', '___4', up to '___8'.

	  It's valid to encode it as four bits (by design).

	  The  {@link msgTtlToSeconds} array provides the actual time in seconds for
	  each value, and {@link msgTtlToString} provides a string description.

	  @public
*/
export type MessageTtl = 0 | 3 | 4 | 5 | 6 | 7 | 8 | 15;
/**
 * The "app" level message format, provided to onMessage (by ChannelSocket), and
 * similar interfaces.
 *
 * 'body' contains whatever the message contents are, most apps won't be accessing
 * the rest of the fields. And they are all populated either by the library
 * or the server.
 *
 * Note that generally apps won't see a message unless it's been validated
 * in a variety of ways.
 *
 * Internally, os384 shuffles messages around as @{link ChannelMessage}.
 *
 * Validator is {@link validate_Message}.
 *
 * @public
 */
export interface Message {
	body: any;
	channelId: ChannelId;
	sender: SBUserId;
	/** implied is userId of channel, but note that all 'private' messages are 'cc' to Owner */
	messageTo?: SBUserId;
	senderPublicKey: SBUserPublicKey;
	senderTimestamp: number;
	/** reconstructed from timestampPrefix */
	serverTimestamp: number;
	/** end of life (timestamp, if present) */
	eol?: number;
	_id: string;
	/** if present, hash of previous message from this sender */
	previous?: string;
	/** if present, there was an error */
	error?: string;
}
/**
 * 'base62' encodes binary data in (pure) alphanumeric format.
 * We use a dictionary of (A-Za-z0-9) and chunks of 32 bytes.
 *
 * We use this for all 'external' encodings of keys, ids, etc.
 *
 * See `arrayBufferToBase62` and `base62ToArrayBuffer` for the
 * actual encoding and decoding functions.
 *
 * @public
 */
export type Base62Encoded = string & {
	_brand?: "Base62Encoded";
};
export declare const b62regex: RegExp;
export declare function isBase62Encoded(value: string | Base62Encoded): value is Base62Encoded;
/**
 * Converts any array buffer to base62.
 * @public
 */
export declare function arrayBufferToBase62(buffer: ArrayBuffer | Uint8Array): string;
/**
 * Converts a base62 string to matching ArrayBuffer.
 * @public
 */
export declare function base62ToArrayBuffer(s: string): ArrayBuffer;
/** @internal */ export type ObjectHandleVersions = "1" | "2" | "3";
/**
 * This is the lowest-level format of shard information that's presented across
 * an API. Internally, the storage server uses slightly different interfaces.
 * @public
 */
export interface ShardInfo {
	version?: ObjectHandleVersions;
	id: Base62Encoded;
	iv?: Uint8Array | Base62Encoded;
	salt?: ArrayBuffer | Base62Encoded;
	actualSize?: number;
	verification?: Promise<string> | string;
	data?: WeakRef<ArrayBuffer> | ArrayBuffer;
}
declare const SB_OBJECT_HANDLE_SYMBOL: unique symbol;
/**
 * ObjectHandle  (extends ShardInfo)
 *
 * ObjectHandle encodes necessary information for a shard, as well as some
 * conveniences for making contents available after it's loaded.
 *
 * - id is a 43 character base62 string that identifies the object. It is used
 *   to retrieve the object from the storage server.
 *
 * - version is a single character string that indicates the version of the
 *   object handle. '1' and '2' are legacy, '3' is current.
 *
 * - key is a 43 character base62
 *
 * - verification is a random (server specific) string that is used to verify
 *   that you're allowed to access the object (specifically, that somebody,
 *   perhaps you, has paid for the object).
 *
 * - iv and salt are optional, but provide some safeguards. Object server
 *   will provide these for an object.
 *
 * - hash can be slightly confusing: it hashes the packaged (but not encrypted,
 *   nor padded) contents. It needs to hash the packaged contents since 'payload'
 *   can be any object, and the hashing needs to operate against an array buffer.
 *   If the object per se is an arraybuffer (eg a chunk of a large file), then
 *   it will nevertheless be hashed in the 'payload' format. This is the hash
 *   that the global 'ChannelApi.knownShards' uses as index.
 *
 * Validator is {@link validate_ObjectHandle}.
 *
 * @public
 */
export interface ObjectHandle extends ShardInfo {
	[SB_OBJECT_HANDLE_SYMBOL]?: boolean;
	key?: Base62Encoded;
	/** if present, clarifies where to get it (or where it was found) */
	storageServer?: string;
	payload?: any;
	type?: string;
	/** hash of the object (hashed in payload format) */
	hash?: string;
	/**
	 * Signature is a base62 encoded string that is used to verify the integrity
	 * of a 'publisher' and the object. It can be used in different ways, but
	 * the corresponding public key is always inside the object. This allows
	 * composite objects (such as os384 applications) to internally define
	 * publisher, and the resulting ObjectHandle can then be signed.
	 * The object will "work" just fine without it, but some other services
	 * (such as the os384 app launcher) will check it.
	 */
	signature?: string;
}
/**
 * Validate ObjectHandle, throws if there's an issue
 * @public
 */
export declare function validate_ObjectHandle(h: ObjectHandle): ObjectHandle;
/**
 * In some circumstances we need to make sure we have a JSON serializable
 * version of the object handle, eg that iv and salt are base62 strings,
 * and that the verification has been resolved
 * @public
 */
export declare function stringify_ObjectHandle(h: ObjectHandle): Promise<ObjectHandle>;
declare const SB_FILE_SYMBOL: unique symbol;
/**
 * A 'file' in os384. Reminder that we do not have 'directories' or
 * 'hierarchical' structure, since they are inherently spatial and 'physical'
 * (eg ordering on a disk). In os384, the primitive is a set: an 'empty
 * directory' would be represented as an empty set which has a path, for
 * example. Any single file is just a singleton set. A 'directory' will be seen
 * as a set of multiple files, where properties such as 'path' and 'fullPath'
 * are retained such that, if ever desired, a 'directory' can be reconstructed.
 *
 * It should also be noted that SBFile works 'behind the curtain', meaning,
 * it assumes that things are decrypted and verified etc. For example, the
 * handles will contain keys, eg, SBFile objects themselves assume that they
 * are always stored or communicated within encrypted contexts.
 *
 * The 'generic/typical' pattern in os384 is that meta data like SBFile would
 * be shared as messages, either individually or as part of a set. Thus, SBFile
 * combines the challenges of key management and meta data, about data.
 *
 * Whenever an SBFile object is 'entering' lib384, pass the object through
 * the constructor.
 *
 * @public
 */
export declare class SBFile {
	_SBFSVersion: string;
	[SB_FILE_SYMBOL]: boolean;
	static appServer?: string;
	/** storage server generally allows larger than this (eg 16 or 32 MiB). however, in various situations,
		it's problematic to juggle lots of these 'in flight' (eg, in edge worker memory). thus, we currently
		limit to 4 MiB, which gives most of the theoretical performance on the client reading side, and appears
		to be tolerated by various other 'things'. */
	static MAX_SBFILE_CHUNK_SIZE: number;
	sb384app?: boolean;
	sb384appType?: string;
	sb384appVersion?: number;
	/** must be _universally unique_, can be constructed in different ways */
	hash?: string;
	/** typically the name on the file system */
	name?: string;
	/** path to where the file is, eg '/' */
	path?: string;
	/** full path from root including file, eg 'canonical' file name and path */
	fullPath?: string;
	/** MIME type, eg "application/pdf";
		we use 'application/vnd.384.sb384app' to signal our own 'set' format
		(not yet registered at https://www.iana.org/form/media-types) */
	type?: string;
	/** size as reported when file was read by browser */
	size?: number;
	/** size it takes up on a shard server (padded, encrypted, etc.) */
	actualFileSize?: number;
	lastModified?: string;
	/**
	 * 'fullName' constructed by sbfs to be _globally_ unique for a file:
	 * name of file ('on disk'), last modified date, size, and sha256 hash of (unencrypted) contents
	 */
	fullName?: string;
	metaDataString?: string;
	timeStamp?: number;
	fileMetaDataMap?: Map<string, SBFile>;
	/** if 'inline', contents is in 'file' */
	fileLocation?: string;
	/** actual file contents (if present); raw contents */
	file?: ArrayBuffer;
	/** historically we only supported up to chunk sizes files; to remain backwards compatible,
		a 'singleton' file (eg a file with contents smaller than chunk size) can either be
		directly as property 'handle', or as a singleton array '[handle]' */
	handle?: ObjectHandle;
	/** file contents are one or more shards. if there are more than one, then all except
		for the last one will be of size 'MAX_SBFILE_CHUNK_SIZE', the last one might be smaller. */
	handleArray?: ObjectHandle[];
	/** if present, a temporary hash array (eg for a set of files); if this is present,
		but 'handleArray' is not, then this is a large file and upload is in progress */
	hashArray?: string[];
	/** if present, link to the file/set on an app server
		eg: `${configuration.sb384appServer}/#${res.id}_${res.verification}_${res.key}_auto` */
	link?: string;
	browserFile?: File;
	constructor(fileInfo?: {
		[key: string]: any;
	});
	/** we use serialization as a forcing point to ensure that the object is complete
		and consistent. our principal use of serialization is in fact not JSON.stringify
		but our own packaging and unpackaging of objects for transmission. See 'getType()'. */
	toJSON(_key?: string): {
		[k: string]: any;
	};
}
/**
 * Helper function (tolerant) to confirm an object is SBFile
 * @public
 */
export declare function isSBFile(obj: any): obj is SBFile;
declare function getObjectKey(fileHashBuffer: BufferSource, salt: ArrayBuffer): Promise<CryptoKey>;
/**
 * Lower level version of fetchData(), that can be used to fetch data from
 * a known (and 'good') handle. Static, requires no other context.
 */
export declare function fetchDataFromHandle(handle: ObjectHandle): Promise<ObjectHandle>;
declare function fetchPayloadFromHandle(h: ObjectHandle): Promise<any>;
declare function fetchPayload(fileOrObject: SBFile | ObjectHandle): Promise<any>;
declare const SB_STORAGE_TOKEN_SYMBOL: unique symbol;
/**
 * Verbose format of a storage token. In most circumstances, you'll only need
 * the 'hash' field (string).
 *
 * Validator is {@link validate_SBStorageToken}.
 * @public
 * */
export interface SBStorageToken {
	[SB_STORAGE_TOKEN_SYMBOL]?: boolean;
	hash: string;
	size?: number;
	motherChannel?: ChannelId;
	created?: number;
	used?: boolean;
	success?: boolean;
}
/**
 * Validates @link{SBStorageToken}, throws if there's an issue.
 * @public
 * */
export declare function validate_SBStorageToken(data: SBStorageToken): SBStorageToken;
/**
 * This is whatever token system the channel server uses.
 *
 * For example with 'channel-server', you could command-line bootstrap with
 * something like:
 *
 * '''bash
 *   wrangler kv:key put --preview false --binding=LEDGER_NAMESPACE "zzR5Ljv8LlYjgOnO5yOr4Gtgr9yVS7dTAQkJeVQ4I7w" '{"used":false,"size":33554432}'
 *
 * This is available in the cli.
 *
 * @public
 *
 */
export type SBStorageTokenHash = string;
/**
 * Generates a new (random) storage token hash in the correct format. Note,
 * this doesn't 'authorize' the token anywhere or associate it with
 * a storage amount.
 */
export declare function generateStorageToken(): SBStorageTokenHash;
/**
 * Implements event handling interface, compatible with EventTarget but also
 * supports 'on', 'off', and 'emit'. Note: entirely 'static', so any class
 * that extends this will implement a global event handler for that class.
 */
export declare class SBEventTarget {
	private static listeners;
	static addEventListener(type: string, callback: (event: Event) => void, _options?: boolean | AddEventListenerOptions): void;
	static removeEventListener(type: string, callback: (event: Event) => void, _options?: boolean | EventListenerOptions): void;
	static dispatchEvent(event: Event): boolean;
	static on(eventName: string, listener: (args: any) => void): void;
	static off(eventName: string, listener: (args: any) => void): void;
	static emit(eventName: string, ...args: any[]): void;
}
/**
 * Basic object handle for a shard (all storage).
 *
 * To RETRIEVE a shard, you need id and verification.
 *
 * To DECRYPT a shard, you need key, iv, and salt. Current
 * generation of shard servers will provide (iv, salt) upon
 * request if (and only if) you have id and verification.
 *
 * Note that id32/key32 are array32 encoded base62 encoded.
 *
 * 'verification' is a 64-bit integer, encoded as a string
 * of up 23 characters: it is four 16-bit integers, either
 * joined by '.' or simply concatenated. Currently all four
 * values are random, future generation only first three
 * are guaranteed to be random, the fourth may be "designed".
 *
 *
 * @typedef {Object} ObjectHandleClass
 * @property {boolean} [SB_OBJECT_HANDLE_SYMBOL] - flag to indicate this is an ObjectHandle
 * @property {string} version - version of this object
 * @property {string} id - id of object
 * @property {string} key - key of object
 * @property {Base62Encoded} [id32] - optional: array32 format of id
 * @property {Base62Encoded} [key32] - optional: array32 format of key
 * @property {Promise<string>|string} verification - and currently you also need to keep track of this,
 * but you can start sharing / communicating the
 * object before it's resolved: among other things it
 * serves as a 'write-through' verification
 * @property {Uint8Array|string} [iv] - you'll need these in case you want to track an object
 * across future (storage) servers, but as long as you
 * are within the same SB servers you can request them.
 * @property {Uint8Array|string} [salt] - you'll need these in case you want to track an object
 * across future (storage) servers, but as long as you
 * are within the same SB servers you can request them.
 * @property {string} [fileName] - by convention will be "PAYLOAD" if it's a set of objects
 * @property {string} [dateAndTime] - optional: time of shard creation
 * @property {string} [shardServer] - optionally direct a shard to a specific server (especially for reads)
 * @property {string} [fileType] - optional: file type (mime)
 * @property {number} [lastModified] - optional: last modified time (of underlying file, if any)
 * @property {number} [actualSize] - optional: actual size of underlying file, if any
 * @property {number} [savedSize] - optional: size of shard (may be different from actualSize)
 *
 * StorageAPI. Used to interact with storage server(s). It will have a concept
 * of a 'default' server, but that is not needed for all operations. It will
 * default to using server choices in any handles.
 *
 * @public
 */
export declare class StorageApi {
	#private;
	static getObjectKey: typeof getObjectKey;
	constructor(server?: string);
	getStorageServer(): Promise<string>;
	/**
	 * Pads object up to closest permitted size boundaries,
	 * taking into account meta data overhead of the padding itself,
	 * increasing privacy by hiding actual size of data.
	 *
	 * Currently, this means minimum size of 4 KiB, after which
	 * we round up to closest power of 2, doing so up to 1 MiB,
	 * after which we round up to the next MiB boundary.
	 */
	static padBuf(buf: ArrayBuffer): ArrayBuffer;
	/**
	 * Reverse of padBuf(). Note that actual size is in the last 4 bytes.
	 */
	static unpadBuf(data_buffer: ArrayBuffer): ArrayBuffer;
	/** derives final object ID */
	static getObjectId(iv: Uint8Array, salt: ArrayBuffer, encryptedData: ArrayBuffer): Promise<string>;
	/**
	 * Paces uploads to avoid overloading the storage server. Takes into account
	 * global number of operations.
	 */
	static paceUploads(): Promise<void>;
	/**
	 * Store 'contents' as a shard, returns an object handle. Note that 'contents' can be
	 * anything, and is always packaged as a payload before storing.
	 */
	storeData(contents: any, budgetSource: ChannelHandle | Channel | SBStorageToken): Promise<ObjectHandle>;
	/**
	 * Fetches the data for a given object handle. Result will be referenced by
	 * the 'payload' property in the returned handle. This is the main 'read'
	 * workhorse. Note it will result in a call to core.fetchDataFromHandle().
	 *
	 * This will work if you have sufficient information in the passed
	 * ObjectHandle. fetchData() will flesh out everything it can, and throw if
	 * it's not able to. It will return the same handle, with whatever additional
	 * parts it was able to fill in.
	 *
	 * Note that fetchData will prioritize checking with the storageServer in the
	 * handle, if present. Next, it will always check localhost at port 3841 if a
	 * local mirror is running. After that, it may or may not check one or several
	 * possible servers. And it might throw if there are inconsisencies.
	 *
	 * Note that 'storageServer' in the returned object might have changed, it
	 * will be whichever server fetchData() was able to fetch from (so could be
	 * local mirror for example, so be a bit careful with overwriting the original
	 * handle that was used).
	 *
	 * The contents of the shard are decrypted and extracted into 'payload', and
	 * 'data' will contain the raw data prior to decryption and extraction, in
	 * case callee is interested. Note that to avoid unnecessary duplication of
	 * space, it is stored as a 'weakref' - use getData() to safely retrieve.
	 *
	 * Note that as a side effect, ChannelApi.knownShards is updated.
	 */
	fetchData(handle: ObjectHandle): Promise<ObjectHandle>;
	/**
	 * Convenience wrapper for object handles: returns the 'data' if it's present,
	 * returns undefined if it's not, and throws an error if the handle is
	 * invalid. Accepts 'undefined' for easier chaining. Note that this is a
	 * low-level operation, you probably want to use fetchPayload() instead.
	 */
	static getData(handle: ObjectHandle | undefined): ArrayBuffer | undefined;
	/**
	 * Convenience wrapper for object handles: returns the payload (eg contents of
	 * the shard). It can parse out if the payload is already present. If not, it
	 * will fetch the data and extract the payload.
	 *
	 * Note: this cannot take an undefined parameter, since it cannot return
	 * 'undefined' as a non-throwing response (because 'undefined' by itself is a
	 * permitted shard content).
	 *
	 * For the same reason, we can't have a non-throwing 'fetchPayload()' method,
	 * that would be analogous to 'getData()'.
	 */
	fetchPayload(h: ObjectHandle): Promise<any>;
}
/**
   * ChannelSocket extends Channel. Has same basic functionality as Channel, but
   * is synchronous and uses websockets, eg lower latency and higher throughput.
   *
   * You send by calling channel.send(msg: SBMessage | string), i.e. you can
   * send a quick string.
   *
   * You can set your message handler upon creation, or later by using
   * channel.onMessage = (m: Message) => { ... }.
   *
   * You don't need to worry about managing resources, like closing it, or
   * checking if it's open. It will close based on server behavior, eg it's up
   * to the server to close the connection based on inactivity. The
   * ChannelSocket will re-open if you try to send against a closed connection.
   *
   * Messages are delivered as type Message if it could be parsed and decrypted;
   * it can also be a string (typically if a low-level server message, in which
   * case it will just be forwarded to the message handler).
   *
   * It also handles a simple ack/nack mechanism with the server transparently.
   *
   * Be aware that if ChannelSocket doesn't know how to handle a certain
   * message, it will generally drop it.
   *
 */
export declare class ChannelSocket extends Channel {
	#private;
	channelSocketReady: Promise<ChannelSocket>;
	static ReadyFlag: symbol;
	onMessage: (_m: Message | string) => void;
	lastTimestampPrefix: string;
	constructor(handleOrKey: ChannelHandle | SBUserPrivateKey, onMessage: (m: Message | string) => void, protocol?: SBProtocol);
	get ready(): Promise<ChannelSocket>;
	get errorPromise(): Promise<ChannelSocket>;
	get ChannelSocketReadyFlag(): boolean;
	get status(): "CLOSED" | "CONNECTING" | "OPEN" | "CLOSING";
	/** Enables debug output */
	set enableTrace(b: boolean);
	/**
	  * ChannelSocket.send()
	  *
	  * Returns a promise that resolves to "success" when sent,
	  * or an error message if it fails.
	  */
	send(contents: any, options?: MessageOptions): Promise<string>;
	/**
	 * This is either called when you're done, or is called internally
	 * during various restart/reconnect scenarios.
	 */
	close(): Promise<void>;
	/**
	 * Reconnects (resets) a ChannelSocket. This will not block (it's
	 * synchronous), and 'ready' will resolve when the socket is ready again.
	 */
	reset(): void;
}
/**
 * Channel and Storage servers return the same structure.
 */
export interface SBServerInfo {
	version: string;
	channelServer: string;
	storageServer: string;
	jslibVersion?: string;
}
export type ServerOnlineStatus = "online" | "offline" | "unknown";
declare const SB_CHANNEL_API_BODY_SYMBOL: unique symbol;
/**
 * Pretty much every api call needs a payload that contains the
 * api request, information about 'requestor' (user/visitor),
 * signature of same, time stamp, yada yada.
 *
 * Validator is {@link validate_ChannelApiBody}
 * @public
 */
export interface ChannelApiBody {
	[SB_CHANNEL_API_BODY_SYMBOL]?: boolean;
	channelId: ChannelId;
	path: string;
	userId: SBUserId;
	userPublicKey: SBUserPublicKey;
	isOwner?: boolean;
	timestamp: number;
	sign: ArrayBuffer;
	apiPayloadBuf?: ArrayBuffer;
	apiPayload?: any;
}
/**
 * Return self if it matches shape, otherwise throw. Extraneous properties are ignored
 *
 * @public
 */
export declare function validate_ChannelApiBody(body: any): ChannelApiBody;
/**
  * Main class. It corresponds to a single channel server. Most apps
  * will only be talking to one channel server, but it is possible
  * to have multiple instances of ChannelApi, each talking to a
  * different channel server.
  *
  * Channel servers are generally associated with a single storage
  * storage, one where the channel server is trusted to make storage
  * allocation decisions.
  *
  * Takes a single parameter, the URL to the channel server.
  *
  * @example
  * ```typescript
  *     const sb = new ChannelApi('http://localhost:3845')
  * ```
  *
  * Websocket server is always the same server (just different protocol),
  * storage server is provided by '/api/v2/info' endpoint from the
  * channel server.
  *
  * You can give an options parameter with various settings, including
  * debug levels. For ease of use, you can just give a boolean value
  * (eg 'true') to turn on basic debugging.
  *
  * It might be a bit confusing given it's name, but the "channel API"
  * is provided by Channels.
  *
  * The 'sbFetch' option allows you to provide a custom fetch function
  * for accessing channel and storage servers. For example, to provide
  * a specific service binding for a web worker.
  *
  * ChannelApi also provides accurate online/offline status (if the
  * channel server supports it). It will emit 'online' and 'offline'
  * events, and you can check 'ChannelApi.onlineStatus'.
 */
export declare class ChannelApi extends SBEventTarget {
	#private;
	static version: string;
	static MAX_MESSAGE_REQUEST_SIZE: number;
	static MAX_MESSAGE_SET_SIZE: number;
	static knownShards: Map<string, ObjectHandle>;
	static lastTimeStamp: number;
	static isShutdown: boolean;
	static lastTimestampPrefix: string;
	static onlineStatus: ServerOnlineStatus;
	static defaultChannelServer: string;
	eventTarget: SBEventTarget;
	static shardBreakpoints: Set<string>;
	fetchPayload: typeof fetchPayloadFromHandle;
	constructor(channelServer: string, options?: {
		DBG?: boolean;
		DBG2?: boolean;
		sbFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
	} | boolean);
	/** Any operations that require a precise timestamp (such as messages) can use
		this, to assure both pacing, uniqueness, and monotonically increasing
		timestamps (on a per-Channel basis)
		*/
	static dateNow(): Promise<number>;
	/**
	 * Call when somethings been heard from any channel server; this is used to
	 * track whether we are online or not.
	 */
	static heardFromServer(): void;
	static checkUnknownNetworkStatus(): void;
	/**
	 * Call when we haven't heard from any channel server for a while, and we
	 * think we should have.
	 */
	static haveNotHeardFromServer(): void;
	static addChannelSocket(socket: ChannelSocket): void;
	static removeChannelSocket(socket: ChannelSocket): void;
	/**
	 * "Anonymous" version of fetching a page, since unless it's locked you do not
	 * need to be authenticated to fetch a page (or even know what channel it's
	 * related to). This will return mime type and payload in 'convenient' format
	 * (eg string, blob, ArrayBuffer, or for JSON is 'any').
	 */
	getPage(prefix: string): Promise<{
		type: string;
		payload: any;
	}>;
	/**
	 * Creates a new channel. Returns a promise to a @link(ChannelHandle} object.
	 * Note that this method does not connect to the channel, it just creates
	 * (authorizes) it and allocates storage budget.
	 *
	 * Note that if you have a full budget channel, you can budd off it (which
	 * will take all the storage). Providing a budget channel here will allows you
	 * to create new channels when a 'guest' on some other channel (for example),
	 * or to create a new channel with a minimal budget.
	 *
	 * ChannelApi.create() returns a handle, whereas Channel.create() returns the
	 * channel itself.
	 */
	create(budgetChannel: Channel): Promise<ChannelHandle>;
	create(storageToken: SBStorageToken): Promise<ChannelHandle>;
	/**
	 * Connects to a channel on this channel server. Returns a @link{Channel}
	 * object unless you provide an onMessage handler, in which case it
	 * returns a @link{ChannelSocket}.
	 */
	connect(handleOrKey: ChannelHandle | SBUserPrivateKey): Channel;
	connect(handleOrKey: ChannelHandle | SBUserPrivateKey, onMessage: (m: Message | string) => void): ChannelSocket;
	/**
	 * Closes all active operations and connections, including any fetches
	 * and websockets. This closes EVERYTHING (globally).
	 */
	static closeAll(): Promise<void>;
	/**
	 * Gets server information on provided server. Note, this will return 'undefined'
	 * if the server is not reachable (it will not throw).
	 */
	static getServerInfo(server?: string): Promise<SBServerInfo | undefined>;
	static traceShard(id: string): void;
	/** Returns the storage API */
	get storage(): StorageApi;
	/** Returns matching storage server */
	getStorageServer(): Promise<string>;
	/** Returns the crypto API */
	get crypto(): SBCrypto;
	/** Returns version */
	get version(): string;
}
/**
 * The minimum state of a Channel is the "user" keys, eg how we identify when
 * connecting to the channel.
 *
 * We can construct them from a {@link ChannelHandle} or from a {@link SBUserPrivateKey}.
 */
export declare class ChannelKeys extends SB384 {
	#private;
	sbChannelKeysReady: Promise<ChannelKeys>;
	static ReadyFlag: symbol;
	/** can be read/written freely; will always have a value */
	channelServer: string;
	constructor(handleOrKey?: ChannelHandle | SBUserPrivateKey);
	get ready(): Promise<ChannelKeys>;
	get SBChannelKeysReadyFlag(): any;
	get owner(): boolean | "";
	get channelId(): string;
	get channelData(): SBChannelData;
	get handle(): ChannelHandle;
	buildApiBody(path: string, apiPayload?: any): Promise<ChannelApiBody>;
	/**
	  * Implements Channel api calls.
	  *
	  * Note that the API call details are also embedded in the ChannelMessage,
	  * and signed by the sender, completely separate from HTTP etc auth.
	  */
	callApi(path: string): Promise<any>;
	callApi(path: string, apiPayload: any): Promise<any>;
}
/** @internal */
export interface TreeNodeValueType {
	type: "messageHistory";
	from: string;
	to: string;
	count: number;
}
/** @internal */
export declare class HistoryTreeNode<FrozenType> {
	isLeaf: boolean;
	childrenNodes: HistoryTreeNode<FrozenType>[];
	childrenValues: TreeNodeValueType[];
	from: string | undefined;
	to: string | undefined;
	count: number;
	isFull: boolean;
	height: number;
	frozenChunkId: FrozenType | undefined;
	constructor(isLeaf?: boolean);
	insertTreeNodeValue(root: HistoryTree<FrozenType>, value: TreeNodeValueType): Promise<void>;
	traverse(root: HistoryTree<FrozenType>, callback: (node: HistoryTreeNode<FrozenType>) => Promise<void>, reverse?: boolean): Promise<void>;
	_iterateValues(node: this, reverse: boolean | undefined, residualSkip: number): AsyncIterableIterator<TreeNodeValueType>;
	/**
	 * Asynchronously traverses all entries in the tree, defrosting
	 * as needed, calling _iterateValues() on each.
	 */
	traverseGenerator(root: HistoryTree<FrozenType>, from: string, to: string, reverse: boolean | undefined, residualSkip: number): AsyncIterableIterator<TreeNodeValueType>;
	traverseValuesGenerator(root: HistoryTree<FrozenType>, from: string, to: string, reverse?: boolean, residualSkip?: number): AsyncIterableIterator<TreeNodeValueType>;
	validate(root: HistoryTree<FrozenType>, valueSize?: number): Promise<void>;
	_callbackValues(node: HistoryTreeNode<FrozenType>, _nodeCallback?: (value: TreeNodeValueType) => Promise<void>, reverse?: boolean): Promise<void>;
	traverseValues(root: HistoryTree<FrozenType>, callback?: (value: TreeNodeValueType) => Promise<void>, reverse?: boolean): Promise<void>;
	export(): any;
	static import<FrozenType>(data: any): HistoryTreeNode<FrozenType>;
}
/**
* Handles an arbitrary number of entries. An entry is of type 'TreeNodeValueType'; it
* will contain, or reference, some set of items, which 'HistoryTree' doesn't
* care about per se. Every set is characterized by having a population count
* ('count'), and a range of index (key) values, ranging from 'from' to 'to',
* inclusive. These indexes are of type 'string' (typically number or
* string).
*
* 'count' of zero is not permitted, and similarly both 'from' and 'to' must
* have values (they are allowed to be the same).
*
* Note that 'TreeNodeValueType' is assumed to be compact.
*
* Only insertion of 'larger' values are permitted; the 'from' index must be
* greater than the highest 'to' value in the tree, and also may not overlap.
*
* 'branchFactor' is self explanatory. If created with 'data', that in turn
* is assumed to be the (exact) same format as a previously exported tree.
*
* @internal
*/
export declare abstract class HistoryTree<FrozenType> {
	branchFactor: number;
	root: HistoryTreeNode<FrozenType>;
	abstract freeze(data: HistoryTreeNode<FrozenType>): Promise<FrozenType>;
	abstract deFrost(data: FrozenType): Promise<HistoryTreeNode<FrozenType>>;
	private insertOrValidateLock;
	private residualSkip;
	constructor(branchFactor: number, data?: any);
	insertTreeNodeValue(value: TreeNodeValueType): Promise<void>;
	traverse(callback: (node: HistoryTreeNode<FrozenType>) => Promise<void>, reverse?: boolean): Promise<void>;
	traverseValues(callback?: (value: TreeNodeValueType) => Promise<void>, reverse?: boolean): Promise<void>;
	traverseValuesGenerator(from: string, to: string, reverse?: boolean): AsyncIterableIterator<TreeNodeValueType>;
	skip(count: number): HistoryTree<FrozenType>;
	validate(valueSize?: number): Promise<void>;
	get from(): string | undefined;
	get to(): string | undefined;
	export(): any;
}
/**
* 'MessageHistory' is where Messages go to retire. It's a scaleable structure
* that can be used to store messages in a flexible way. Chunks of messages are
* stored as shards, in the form of a payload wrapped Map (key->message), where
* each message in turn is a payload-wrapped ChannelMessage.
*
* This can be thought of as a flexible 'key-value store archive format' (where
* the keys are globally unique and monotonically increasing).
*
* The channel server keeps the 'latest' messages (by some definition) in a
* straight KV format; overflow (or archiving) is done by processing messages
* into this structure.
*
* The class for the whole thing is 'DeepHistory', below. It is a variant of a
* Merkle tree (strictly speaking, it's only a Merkle tree when fully 'frozen').
*
* @public
*/
export interface MessageHistory extends TreeNodeValueType {
	version: "20240603.0";
	channelId: ChannelId;
	ownerPublicKey: SBUserPublicKey;
	created: number;
	size?: number;
	shard: ObjectHandle;
}
/**
* Full deep history ("DH") feature. If no budget is provided, it will be in
* read-only mode. Uses Tree with index type 'string' (eg channelId + '_' +
* subChannel + '_' + timestampPrefix). The 'values' handled by HistoryTree are
* MessageHistory, and this class will encapsulate shardifying the lowest level,
* eg 'leaf' nodes with between ~128 and 512 messages.
*
* Note that the channel server has a parallel class to this ('ChannelHistory')
*
* @public
*/
export declare abstract class DeepHistory<FrozenType> extends HistoryTree<FrozenType> {
	branchFactor: number;
	abstract storeData(data: any): Promise<FrozenType>;
	abstract fetchData(handle: FrozenType): Promise<any>;
	static MAX_MESSAGE_HISTORY_SHARD_SIZE: number;
	constructor(branchFactor: number, data?: any);
	freeze(data: HistoryTreeNode<FrozenType>): Promise<FrozenType>;
	deFrost(handle: FrozenType): Promise<any>;
	/** returns timestamp form of FIRST message covered by this history (use 'from' for prefix format) */
	get fromTimestamp(): number | undefined;
	/** returns timestamp form of LAST message covered by this history (use 'to' for prefix format) */
	get toTimestamp(): number | undefined;
}
export declare abstract class ServerDeepHistory extends DeepHistory<ObjectHandle> {
	static MESSAGE_HISTORY_BRANCH_FACTOR: number;
	static MAX_MESSAGE_SET_SIZE: number;
	constructor(data: any);
	insert(data: MessageHistory): Promise<void>;
	fetchData(_handle: ObjectHandle): Promise<any>;
}
/**
 * Client-side Deep History.
 * @public
 */
export declare class ClientDeepHistory extends DeepHistory<ObjectHandle> {
	private channel;
	private SB;
	constructor(data: any, channel: Channel);
	storeData(_data: any): Promise<ObjectHandle>;
	fetchData(handle: ObjectHandle): Promise<any>;
	traverseMessagesGenerator(from: number, to: number, reverse: boolean): AsyncIterableIterator<Message>;
	traverseMessagesEncrypted(callback: (id: string, value: ChannelMessage) => Promise<void>): Promise<void>;
	validate(): Promise<void>;
}
declare const SB_CHANNEL_HANDLE_SYMBOL: unique symbol;
/**
 * This is what the {term}`Channel` Server knows about the channel.
 *
 * Note: all of these are (ultimately) strings, and are sent straight-up
 * to/from channel server.
 *
 * Validator is {@link validate_SBChannelData}.
 *
 * @public
 */
export interface SBChannelData {
	channelId: ChannelId;
	ownerPublicKey: SBUserPublicKey;
	storageToken?: SBStorageToken;
}
/**
 * Validates 'SBChannelData', throws if there's an issue
 * @public
 */
export declare function validate_SBChannelData(data: any): SBChannelData;
/**
 * This corresponds to all important meta-data on a channel that an Owner
 * has access to.
 *
 * @public
 */
export interface ChannelAdminData {
	channelId: ChannelId;
	channelData: SBChannelData;
	capacity: number;
	locked: boolean;
	accepted: Set<SBUserId>;
	visitors: Map<SBUserId, SBUserPublicKey>;
	storageLimit: number;
	motherChannel: ChannelId;
	latestTimestamp: string;
}
export interface EnqueuedMessage {
	msg: ChannelMessage;
	resolve: (value: any) => any;
	reject: (reason: any) => any;
	_send: (msg: ChannelMessage) => any;
	retryCount: number;
}
/**
 * Channels are the core communication and 'read/write' object.
 *
 * The Channel class communicates asynchronously with the channel.
 *
 * The ChannelSocket class is a subclass of Channel, and it communicates
 * synchronously (via websockets).
 *
 * Protocol is called for every message to get the CryptoKey to use for that
 * message; if provided, then it's the default for each message. Individual
 * messages can override this. Upon sending, one or the other needs to be there.
 * The default protocol is Protocol_ECDH, which does basic sender-receipient
 * public key encryption.
 *
 * The interface equivalent of a Channel is {@link ChannelHandle}.
 *
 * Note that you don't need to worry about what API calls involve race
 * conditions and which don't, the library will do that for you. Like most
 * classes in SB it follows the "ready" template: objects can be used right
 * away, but they decide for themselves if they're ready or not. The SB384 state
 * is the *user* of the channel, not the channel itself; it has an Owner (also
 * SB384 object), which can be the same as the user/visitor, but that requires
 * finalizing creating the channel to find out (from the channel server).
 *
 * The channel endpoint itself looks as follows, for both visitors and owners
 * (there is a corresponding method for most of these):
 *
 * ```plaintext
 *     /api/v2/channel/<ID>/getChannelKeys      :     get owner pub key, channel pub key, etc
 *     /api/v2/channel/<ID>/getHistory          :     returns a deep history of messages
 *     /api/v2/channel/<ID>/getLatestTimestamp  :     latest message timestamp, in prefix format
 *     /api/v2/channel/<ID>/getMessages         :     given keys, get messages
 *     /api/v2/channel/<ID>/getMessageKeys      :     get message keys
 *     /api/v2/channel/<ID>/getPubKeys          :     returns Map<userId, pubKey>
 *     /api/v2/channel/<ID>/getStorageLimit     :     returns storage limit
 *     /api/v2/channel/<ID>/getStorageToken     :     mint a storage token
 *     /api/v2/channel/<ID>/send                :     send a message
 *     /api/v2/channel/<ID>/websocket           :     upgrades to websocket protocol
 * ```
 *
 * And the following endpoints are for owners only:
 *
 * ```plaintext
 *     /api/v2/channel/<ID>/acceptVisitor       :     adds a vistor to the channel
 *     /api/v2/channel/<ID>/budd                :     either creates a new channel or transfers storage
 *     /api/v2/channel/<ID>/getAdminData        :     returns all admin data in one struct
 *     /api/v2/channel/<ID>/getCapacity         :     returns max number of visitors
 *     /api/v2/channel/<ID>/getJoinRequests     :     for locked channels, returns pending join requests
 *     /api/v2/channel/<ID>/getMother           :     returns the mother channel
 *     /api/v2/channel/<ID>/lockChannel         :     locks down the channel (must be 'accepted')
 *     /api/v2/channel/<ID>/setCapacity         :     sets max number of visitors
 *     /api/v2/channel/<ID>/setPage             :     sets the page for the channel
 * ```
 *
 * There are also a number of wrapper/convenience methods.
 *
 */
export declare class Channel extends ChannelKeys {
	#private;
	channelReady: Promise<Channel>;
	static ReadyFlag: symbol;
	locked?: boolean;
	defaultProtocol: SBProtocol;
	protocol?: SBProtocol;
	sendQueue: MessageQueue<EnqueuedMessage>;
	closingDown: boolean;
	previous: string | undefined;
	/**
	 * Channel supports creation from scratch, from a handle, or from a key.
	 * With no parameters, you're creating a channel from scratch, which
	 * means in particular it creates the Owner keys. The resulting object
	 * can be recreated from `channel.userPrivateKey`. A from-scratch
	 * Channel is an "abstract" object, a mathematical construct, it isn't
	 * yet hosted anywhere. But it's guaranteed to be globally unique.
	 */
	constructor();
	/**
	 * In the special case where you want to create a Channel from scratch,
	 * and immediately start using it, you can directly pass a protocol and
	 * mark absense of a handle with `null`.
	 */
	constructor(newChannel: null, protocol: SBProtocol);
	/**
	 * If you are re-creating a Channel from the Owner private key, you
	 * can so so directly.
	 */
	constructor(key: SBUserPrivateKey, protocol?: SBProtocol);
	/**
	 * If you have a full (or partial) handle present, you can use that as well;
	 * for example it might already contain the name of a specific channel server,
	 * the ChannelData from that server for the channel, etc. This is also the
	 * quickest way, since bootstrapping from keys requires more crypto.
	 *
	 * @param handle - ChannelHandle
	 * @param protocol - SBProtocol
	 */
	constructor(handle: ChannelHandle, protocol?: SBProtocol);
	get ready(): Promise<Channel>;
	get ChannelReadyFlag(): boolean;
	get api(): this;
	/**
	 * Returns a map of all known participants - maps SBUserdId to SBUserPublicKey.
	 * Note that this will poke the server; if you just want to look up individual
	 * visitors, you can use 'getVisitorKeyFromId()' or 'getVisitorIdFromKey()',
	 * which will be faster (caching results).
	 */
	getPubKeys(): Promise<Map<SBUserId, SBUserPublicKey>>;
	/**
	 * Translates an SBUserId to an SBUserPublicKey, for this channel. This will
	 * be fast, and it will ping server if and when needed. 'undefined' is a
	 * permitted value, it will return the public key of the channel owner.
	 */
	getVisitorKeyFromID(userId: SBUserId | undefined): Promise<SBUserPublicKey | undefined>;
	/**
	 * Reverse of 'getVisitorKeyFromID()'. Translates an SBUserPublicKey to an SBUserid.
	 * Note, it will return undefined if the public key is not found in the visitor map
	 * of this channel. You can always create the ID directly with:
	 *
	 * ```typescript
	 *
	 *      const id = (await new SB384(publicKey).ready).userId
	 *
	 * ```
	 *
	 * This function deliberately does not do this, on the assumption that you prefer
	 * to find out if this key is not on the channel's visitor list.
	 */
	getVisitorIDFromKey(userId: SBUserPublicKey): Promise<SBUserId | undefined>;
	/**
	 * Takes a 'ChannelMessage' format and presents it as a 'Message'. Does a
	 * variety of things. If there is any issue, will return 'undefined', and you
	 * should probably just ignore that message. Only requirement is you extract
	 * payload before calling this (some callees needs to, or wants to, fill in
	 * things in ChannelMessage). If 'dbgOn' is set, will print out
	 * debugging information.
	 */
	extractMessage(msgRaw: ChannelMessage | undefined, dbgOn?: boolean): Promise<Message | undefined>;
	/**
	 * Applies 'extractMessage()' to a map of messages.
	 */
	extractMessageMap(msgMap: Map<string, ChannelMessage>): Promise<Map<string, Message>>;
	/**
	 * Convenience function. Takes either a SBUserId or a SBUserPrivateKey,
	 * and will return the SBUserId. Validates along the way. Any issues
	 * result in returning 'undefined'.
	 */
	sendToToUserId(sendTo: SBUserId | SBUserPrivateKey): SBUserId | undefined;
	/**
	 * when *sending* messages, the processing of a message is divided into a
	 * synchronous and an asynchronous part. 'packageMessage()' is the synchronous
	 * part, and 'finalizeMessage()' is the asynchronous part. this way we enqueue
	 * as fast as possible, whereas dequeueing where for instance sender timestamp
	 * semantics are enforced, is done async off a queue.
	 *
	 * everything is a 'ChannelMessage' unless it's a low-level message of some
	 * sort, which we call 'stringMessage' (eg status, server, etc)
	 */
	packageMessage(contents: any, options?: MessageOptions): ChannelMessage;
	finalizeMessage(msg: ChannelMessage): Promise<ChannelMessage>;
	/**
	 * Sends a message to the channel. The message is enqueued synchronously and sent
	 * asynchronously. The return value is a Promise that resolves to the
	 * server's response. If the message is a low-level message (eg status, server,
	 * etc), then 'sendString' should be set to 'true'. If 'sendTo' is not provided,
	 * the message will be sent to the channel owner. If 'protocol' is not provided,
	 * the channel's default protocol will be used. If 'ttl' is not provided, it will
	 * default to 15.
	 */
	send(contents: any, options?: MessageOptions): Promise<string>;
	/** Authorizes/registers this channel on the provided server */
	create(storageToken: SBStorageToken, channelServer?: ChannelId): Promise<Channel>;
	/** Deprecated. Would take an array of channelIds and get latest time stamp from all of them  */
	getLastMessageTimes(): void;
	/**
	 * Gets the latest known timestamp for the channel, using server timestamps.
	 * Returns it in prefix string format.
	 */
	getLatestTimestamp(): Promise<string>;
	messageQueueManager(): Promise<void>;
	close(): Promise<void>;
	/**
	 * Returns map of message keys from the server corresponding to the request.
	 * Takes a single optional parameter, which is the time stamp prefix for
	 * which a set is requested. If not provided, the default is '0' (which
	 * corresponds to entire history). Returns a set of the message keys,
	 * and the reverse-linked history shard if present.
	 *
	 * Note that if the channel is out of budget (eg "frozen" or in "deep
	 * history" mode), it will return an empty set of keys (not an error).
	 *
	 * Use 'getMessageMap' to get the actual messages from the set of keys.
	 *
	 * See 'getHistory' for older message keys.
	 *
	 * 'historyShard' is deprecated, and will be removed in a future version;
	 * currently it just returns an empty object.
	 *
	 * 'prefix' is about to be deprectated as well.
	 *
	 * @public
	 */
	getMessageKeys(prefix?: string): Promise<{
		historyShard: ObjectHandle | undefined;
		keys: Set<string>;
	}>;
	/**
	 * Get raw set of messages from the server. This corresponds to the 'getMessages' server
	 * endpoint, and distinguished from 'getMessageMap' which you're more likely to be using.
	 * @public
	 */
	getRawMessageMap(messageKeys: Set<string>): Promise<Map<string, ArrayBuffer>>;
	/**
	 * given a raw set of messages, extract payloads, validate (at ChannelMessage level),
	 * then call extractMessageMap() to decrypt. generally you won't be using this, but it's
	 * exposed in case you want to first review the raw messages and then separately decrypt
	 * and validate them.
	 */
	convertRawMessageMap(messagePayloads: Map<string, ArrayBuffer>): Promise<Map<string, Message>>;
	/**
	 * Main function for getting a chunk of messages from the server.
	 * Note that if you want "raw" messages (unencrypted), use 'getRawMessageMap()'.
	 */
	getMessageMap(messageKeys: Set<string>): Promise<Map<string, Message>>;
	/**
	 * Returns a DeepHistory object corresponding to the channel. Note:
	 * this will (live) instantiate this object at the time of calling
	 * this function. The returned object is not kept in 'sync' with the
	 * server in any manner. This allows calling traverse and similar
	 * operations on it, repeatedly. Calling this function multiple times
	 * is, in fact, not a lot of overhead, given the nature of the history
	 * tree structure (eg it's mostly immutable).
	 */
	getHistory(): Promise<ClientDeepHistory>;
	/**
	 * Sets 'page' as the Channel's 'page' response. If type is provided, it will
	 * be used as the 'Content-Type' header in the HTTP request when retrieved;
	 * also, if the type is 'text-like', it will be recoded to UTF-8 before
	 * delivery. Prefix indicates the smallest number of acceptable characters in
	 * the link. Default is 12, shortest is 6.
	 */
	setPage(options: {
		page: any;
		prefix?: number;
		type?: string;
	}): Promise<any>;
	/**
	 * Note that 'getPage' can be done without any authentication, in which
	 * case have a look at ChannelApi.getPage(). If however the Page is locked,
	 * you need to access it through this ChannelApi entry point.
	 *
	 * But conversely, we don't need a prefix or anything else, since
	 * we know the channel. So .. we can just shoot this off.
	 *
	 * Note that a 'Page' might be mime-typed, in which case you should
	 * use a regular fetch() call and handle results accordingly. This
	 * function is for 'sb384payloadV3' only.
	 */
	getPage(): Promise<any>;
	/**
	 * Writes a key-value to the channel. Values can be any type and are
	 * mutable.
	 *
	 * Size of an individual value can be up to 4 MiB, but note that channel KV
	 * storage is (much) more expensive than shard/object storage, so you're
	 * generally better off shardifying large values.
	 *
	 * If the channel is out of budget, KV writes allow a small amount of
	 * "overdraft". This allows you to update small amount of KV state to avoid
	 * inconsistencies, for example a counter or other summary information.
	 *
	 */
	put(key: any, value: any, encrypt?: boolean): Promise<any>;
	/**
	 * Reads a key-value from the channel. If key is not found, it will return
	 * 'undefined'.
	 */
	get(key: any): Promise<any>;
	/**
	 * Adds 'SBUserId' to accepted visitors. Owner only.
	 */
	acceptVisitor(userId: SBUserId): Promise<any>;
	/**
	 * Returns with total number of permitted (different) visitors/users. Owner only.
	 * Default for a channel is to accept anybody that comes along, to change that
	 * you would call 'localChannel()'
	 */
	getCapacity(): Promise<any>;
	getInfo(): Promise<any>;
	/**
	 * Returns a structure with various channel information. Owner only.
	 * For common pieces of information there various convenience functions.
	 */
	getAdminData(): Promise<ChannelAdminData>;
	/**
	 * Convenience function. Returns 'mother' channel, if any. Owner only.
	 */
	getMother(): Promise<string>;
	/**
	 * Convenience function. Returns boolean for whether channel is locked or not. Owner only.
	 */
	isLocked(): Promise<boolean>;
	/**
	 * Locks down the channel (only visitors the Owner has pre-approved have access).
	 * Owner only.
	 */
	lock(): Promise<{
		success: boolean;
	}>;
	/**
	 * Same as lock(). Owner only
	 */
	lockChannel(): Promise<{
		success: boolean;
	}>;
	/** Sets limit of number of (different) visitors that can join. Owner only. */
	setCapacity(capacity: number): Promise<any>;
	/** Sets limit of number of (different) visitors that can join. Same as setCapacity. Owner only. */
	updateCapacity(capacity: number): Promise<any>;
	/**
	 * Returns the 'channel data' structure: various keys etc.
	 */
	getChannelKeys(): Promise<SBChannelData>;
	/**
	 * Returns amount of storage available to 'you' on the channel.
	 * Currently this is all the budget (please do not abuse),
	 * but in the future this will be on a per-user basis. (Except for Owner)
	 */
	getStorageLimit(): Promise<any>;
	/**
	 * 'Mint' a storaged token off a channel.
	 */
	getStorageToken(size: number): Promise<SBStorageToken>;
	/**
	 * "budd" will spin a channel off an existing one that you own,
	 * or transfer storage budget to an existing channel.
	 *
	 * You need to provide one of the following combinations of info:
	 *
	 * - nothing: creates new channel with minmal permitted budget
	 * - just storage amount: creates new channel with that amount, returns new channel
	 * - just a target channel: moves a chunk of storage to that channel
	 * - target channel and storage amount: moves that amount to that channel
	 * - keys and storage amount: creates new channel with those keys and that storage amount
	 * - if there's a storage token, add that storage to the channel (ignores size)
	 *
	 * If you want to budd into a channel with specific keys, you'll need to
	 * create a new set of keys (ChannelKeys) and pass the SBChannelData from that.
	 *
	 * It returns a complete ChannelHandle, which will include the private key
	 *
	 * Another way to remember the above: all combinations are valid except
	 * both a target channel and assigning keys.
	 *
	 * In terms of 'keys', you can provide a JsonWebKey, or a SBUserPrivateKey,
	 * or a channel handle. JWK is there for backwards compatibility.
	 *
	 * Note: if you're specifying the target channel, then the return values will
	 * not include the private key (that return value will be empty).
	 *
	 * Note: the owner of the target channel will get a message that you budded
	 * into their channel, which includes the channelId it was budded from.
	 *
	 * Note: a negative storage amount is interpreted as 'leave that much behind'.
	 *
	 * Any indications that your parameters are wrong will result in a rejected
	 * promise. This includes if you ask for more storage than is there, or if
	 * your negative value is more than the storage budget that's there.
	 *
	 * If the budget and target channels are the same, it will throw.
	 *
	 * If you omit budget size, it will use the smallest allowed new channel
	 * storage (currently 32 MB). This will happens regardless of if you are
	 * creating a new channel, or 'depositing'.
	 *
	 * If you give the size value of 'Infinity', then all the storage available
	 * on the source channel will be transferred to the target channel
	 * (aka 'plunder').
	 *
	 * On the server side, budd is in two steps, first extracting the storage
	 * budget from the mother channel, and then creating or transferring the
	 * storage budget to the target channel.
	 *
	 */
	budd(options?: {
		targetChannel?: ChannelHandle;
		size?: number;
		token?: SBStorageToken;
	}): Promise<ChannelHandle>;
	/**
	 * Returns the 'lowest' possible timestamp.
	 */
	static LOWEST_TIMESTAMP: string;
	/**
	 * Returns the 'lowest' possible timestamp.
	 */
	static HIGHEST_TIMESTAMP: string;
	/**
	 * Converts from timestamp to 'base 4' string used in message IDs.
	 *
	 * Time stamps are monotonically increasing. We enforce that they must be
	 * different. Stored as a string of [0-3] to facilitate prefix searches (within
	 * 4x time ranges). We append "0000" for future needs, for example if we need
	 * above 1000 messages per second. Can represent epoch timestamps for the next
	 * 400+ years. Currently the appended "0000" is stripped/ignored.
	 *
	 * Note: '0' will return LOWEST_TIMESTAMP, 'Infinity' will return HIGHEST_TIMESTAMP.
	 *
	 * If 'tsNum' is undefined it will return undefined.
	 */
	static timestampToBase4String(tsNum: number | undefined): string | undefined;
	/**
	 * Converts the server format (base4) to a string timestamp (ISO format).
	 */
	static base4stringToDate(tsStr: string): string;
	/**
	 * Will take values (or keys), and return the lowest and highest values;
	 * empty data is fine and will return '[]' (falsey).
	 */
	static getLexicalExtremes<T extends number | string>(set: Set<T> | Array<T> | Map<T, any>): [
		T,
		T
	] | [
	];
	/**
	 * Given a set of (full) keys, reviews all the timestamp prefixes, and returns
	 * the shortest prefix that would range all the keys in the set.
	 */
	static messageKeySetToPrefix: (keys: Set<string>) => string;
	static timestampLongestPrefix: (s1: string, s2: string) => string;
	static timestampRegex: RegExp;
	/**
	 * Reverse of timestampToBase4String. Strict about the format (needs to be
	 * `[0-3]{26}`), returns undefined if there's any issue. LOWEST_TIMESTAMP
	 * will return 0, HIGHEST_TIMESTAMP will return Infinity.
	 */
	static base4StringToTimestamp(tsStr: string): number | undefined;
	static base4StringToDate(tsStr: string): string | undefined;
	/**
	 * Teases apart the three elements of a channel message key. Note, this does not
	 * throw if there's an issue, it just sets all the parts to '', which should
	 * never occur. Up to you if you want to run with that result or assert on it.
	 * Strict about the format (defined as `[a-zA-Z0-9]{43}_[_a-zA-Z0-9]{4}_[0-3]{26}`).
	 *
	 * Note that '____' is the default subchannel.
	 */
	static deComposeMessageKey(key: string): {
		channelId: string;
		i2: string;
		timestamp: string;
	};
	/**
	 * Creates a 'message key' from constituent parts.
	 */
	static composeMessageKey(channelId: ChannelId, timestamp: number, subChannel?: string): string;
}
/**
 * Key exchange protocol. Note
 *
 * that SBMessage always includes
 * a reference to the channel. Also note that all this methods
 * are likely to be asynchronous (you'll need await).
 * @public
 */
export interface SBProtocol {
	/** even if not used by the protocol, this is set by the channel once the
		protocol is associated with it; note that if a protocol needs to do
		prelimaries once it knows the channel, it needs to track that itself.
		*/
	setChannel(channel: Channel): Promise<void>;
	/** if the protocol doesn't 'apply' to the message, this should throw */
	encryptionKey(msg: ChannelMessage): Promise<CryptoKey>;
	/** 'undefined' means it's outside the scope of our protocol, for example
		 if we're not a permitted recipient, or keys have expired, etc */
	decryptionKey(msg: ChannelMessage): Promise<CryptoKey | undefined>;
}
/**
 * Superset of what different protocols might need. Their meaning
 * depends on the protocol
 */
export interface Protocol_KeyInfo {
	salt1?: ArrayBuffer;
	salt2?: ArrayBuffer;
	iterations1?: number;
	iterations2?: number;
	hash1?: string;
	hash2?: string;
	summary?: string;
}
/**
 * Basic protocol, just provide entropy and salt, then all messages are
 * encrypted accordingly.
 *
 * Note that the AES protocol does not depend on any per-message information,
 * nor particulars of sender or recipient. Thus, for example, getting a key will
 * never return 'undefined', but instead will throw if something is wrong (such
 * as missing salt).
 */
export declare class Protocol_AES_GCM_256 implements SBProtocol {
	#private;
	constructor(passphrase: string, keyInfo: Protocol_KeyInfo);
	ready(): Promise<void>;
	setChannel(_channel: Channel): Promise<void>;
	initializeMasterKey(passphrase: string): Promise<CryptoKey>;
	static genKey(): Promise<Protocol_KeyInfo>;
	encryptionKey(msg: ChannelMessage): Promise<CryptoKey>;
	decryptionKey(msg: ChannelMessage): Promise<CryptoKey>;
}
/**
 * Essentially implements 'whisper', eg 1:1 public-key based encryption between
 * sender and receiver. It will use as sender the private key used on the
 * Channel, and you can either provide 'sendTo' in the SBMessage options, or
 * omit it in which case it will use the channel owner's public key.
 *
 * Careful not to be 'reusing' this protocol for different channels and/or
 * different users. It will be particular to the channel that it is (eventually)
 * configured for (using setChannel()).
 */
export declare class Protocol_ECDH implements SBProtocol {
	#private;
	/**
	 * For debugging support, you can set this map to translate keys to descriptive
	 * names. This is not used by the protocol itself, only bug DBG0 output.
	 */
	static keyToName: Map<SBUserId | SBUserPublicKey, string>;
	constructor();
	setChannel(ch: Channel): Promise<void>;
	encryptionKey(msg: ChannelMessage): Promise<CryptoKey>;
	decryptionKey(msg: ChannelMessage): Promise<CryptoKey | undefined>;
}
declare const SB_CHANNEL_MESSAGE_SYMBOL: unique symbol;
/**
 * SB standard wrapped encrypted messages. This is largely 'internal', normal
 * usage of the library will work at a higher level, see @link{Message}.
 *
 * Encryption is done with AES-GCM, 16 bytes of salt.
 *
 * Timestamp prefix is twenty six (26) [0-3] characters. It encodes epoch
 * milliseconds * 4^4 (last four are '0000').
 *
 * "Everything is optional" as this is used in multiple contexts.
 *
 * Note that channel server doesn't need userPublicKey on every channel message
 * since it's provided on websocket setup.
 *
 * Complete channel "\_id" is channelId + '\_' + subChannel + '\_' +
 * timestampPrefix This allows (prefix) searches within time spans on a per
 * channel (and if applicable, subchannel) basis. Special subchannel 'blank'
 * (represented as '____') is the default channel and generally the only one
 * that visitors have access to.
 *
 * A core exception is that all messages with a TTL in the range 1-7 (eg range
 * of 1 minute to 72 hours) are duplicated onto subchannels matching the TTLs,
 * namely '___1', '___2', '___3', etc. Thus an oldMessages fetch can for example
 * request '___4' to get all messages that were sent with TTL 4 (eg 1 hour).
 * Which also means that as Owner, if you set TTL on a message then you can't
 * use the fourth character (if you try to while setting a TTL, channel server
 * will reject it).
 *
 * Properties that are generally retained or communicated inside payload
 * packaging have short names (apologies for lack of readability).
 * 'unencryptedContents' has a long and cumbersome name for obvious reasons.
 *
 * There are a couple of semantics that are enforced by the channel server;
 * since this is partly a policy issue of the channel server, anything in this
 * documentation might be incomplete. For example, baseline channel server
 * does not allow messages to both be 'infinite ttl' and addressed (eg have a
 * 'to' field value).
 *
 * If any protocol wants to do additional or different encryption, it would need
 * to wrap: the core binary format is defined to have room for iv and salt, and
 * prescribes sizes 12 and 16 respectively. Strictly speaking, the protocol can
 * use these 28 bytes for whatever it wants. A protocol that wants to do
 * something completely different can simply modify the 'c' (contents) buffer
 * and append any binary data it needs.
 *
 * Validator is {@link validate_ChannelMessage}.
 *
 * @public
 */
export interface ChannelMessage {
	[SB_CHANNEL_MESSAGE_SYMBOL]?: boolean;
	/** 'from': public (hash) of sender, matches publicKey of sender, verified by channel server */
	f?: SBUserId;
	/** encrypted contents, or an unencrypted 'string message' if 'stringMessage' is true */
	c?: ArrayBuffer | string;
	/** nonce, always present whether needed by protocol or not (12 bytes) */
	iv?: Uint8Array;
	/** salt, always present whether needed by protocol or not (16 bytes) */
	salt?: ArrayBuffer;
	/** sender signature */
	s?: ArrayBuffer;
	/** timestamp at point of encryption, by client, verified along with encrypt/decrypt */
	ts?: number;
	/** channel server, if present, clarifies where message was processed */
	cs?: string;
	/** (optional) channelId base62 x 43 */
	channelId?: ChannelId;
	/** (optional) subchannel; default is '____', can be any 4xbase62; only owner can read/write subchannels */
	i2?: string;
	/**  timestamp from server */
	sts?: number;
	/** string/base4 encoding of timestamp (see timestampToBase4String) */
	timestampPrefix?: string;
	/** '_id' format is: channelId + '\_' + subChannel + '\_' + timestampPrefix */
	_id?: string;
	/** if present, hash of previous message from this sender */
	p?: string;
	/** whatever is being sent; should (must) be stripped when sent. when
		encrypted, this is packaged as payload first (signing is done on the
		payload version) */
	unencryptedContents?: any;
	/** internal, if true then do not package (special 'string' message type) */
	stringMessage?: boolean;
	/** if present, signals other side is ready to receive messages (rest of message ignored) */
	ready?: boolean;
	/** if present, signals error (and rest of message ignored) */
	error?: string;
	/** 'to': public (hash) of recipient; note that Owner sees all messages; if omitted usually means broadcast */
	t?: SBUserId;
	/** Value 0-15; if it's missing it's 15/0xF (infinite); if it's 1-7 it's duplicated to subchannels */
	ttl?: MessageTtl;
	/** protocol to be used for message */
	protocol?: SBProtocol;
}
/**
 * Validates 'ChannelMessage', throws if there's an issue. Checks for a lot
 * of things. It does not explain itself. Don't count on it to catch everything.
 * Note that you should use the returned value, as this function might fix
 * some minor things (like converting iv from ArrayBuffer to Uint8Array).
 * @public
 */
export declare function validate_ChannelMessage(body: ChannelMessage): ChannelMessage;
/**
 * Complements validate_ChannelMessage. This is used to strip out the parts that
 * are not strictly needed. Addresses privacy, security, and message size
 * issues. Note that 'ChannelMessage' is a 'public' interface, in the sense that
 * this is what is actually stored (as payload ArrayBuffers) at rest, both on
 * servers and clients.
 *
 * 'serverMode' is slightly more strict and used by server-side code.
 *
 * @internal
 */
export declare function stripChannelMessage(msg: ChannelMessage, serverMode?: boolean): ChannelMessage;
/** @public */
export type StrongPinOptions = {
	extraEntropy?: string;
	enforceMix?: boolean;
	setCount?: number;
};
declare function encodeStrongPin(num: number): string;
/**
 * Generates a strongpin with A SINGLE set of 4-characters.
 * (19 bits of entropy).
 *
 *  Convenience function.
 * @public
 */
export declare function generateStrongPin(options?: StrongPinOptions): Promise<string>;
/**
 * generateStrongPin16()
 *
 * Generates a strongpin with 4 sets of 4-characters each.
 * (19 bits of entropy per set, 76 bits total).
 *
 * Convenience function.
 * @public
 */
export declare function generateStrongPin16(options?: StrongPinOptions): Promise<string>;
declare function processStrongPin(str: string): string;
declare function decodeStrongPin(encoded: string): number | null;
/**
 * 'hydrates' a key - if needed; if it's already good on hydration, just returns it.
 * Providing pubKey (from other source) is optional so that you can use this function
 * to easily confirm that a key is hydrated, it will return undefined if it's not.
 * @public
 */
export declare function hydrateKey(privKey: SBUserPrivateKey, pubKey?: SBUserPrivateKey): SBUserPrivateKey | undefined;
/**
 * This is eseentially web standard type AesGcmParams, but with properties being
 * optional - they'll be filled in at the "bottom layer" if missing (and if
 * needed).
 *
 * @internal
 */
export interface EncryptParams {
	name?: string;
	iv?: ArrayBuffer;
	additionalData?: BufferSource;
	tagLength?: number;
}
/**
  * Utility class for SB crypto functions. Generally we use an object
  * instantiation of this (typically ''sbCrypto'') as a global variable.
  *
  * 'SBCrypto' provides a class with wrappers for subtle crypto, as well as some
  * SB-specific utility functions.
  *
  * Typically a public jsonwebkey (JWK) will look something like this in json
  * string format:
  *
  *                        "{\"crv\":\"P-384\",\"ext\":true,\"key_ops\":[],\"kty\":\"EC\",
  *                        \"x\":\"9s17B4i0Cuf_w9XN_uAq2DFePOr6S3sMFMA95KjLN8akBUWEhPAcuMEMwNUlrrkN\",
  *                        \"y\":\"6dAtcyMbtsO5ufKvlhxRsvjTmkABGlTYG1BrEjTpwrAgtmn6k25GR7akklz9klBr\"}"
  *
  * A private key will look something like this:
  *
  *                       "{\"crv\":\"P-384\",
  *                       \"d\":\"KCJHDZ34XgVFsS9-sU09HFzXZhnGCvnDgJ5a8GTSfjuJQaq-1N2acvchPRhknk8B\",
  *                       \"ext\":true,\"key_ops\":[\"deriveKey\"],\"kty\":\"EC\",
  *                       \"x\":\"rdsyBle0DD1hvp2OE2mINyyI87Cyg7FS3tCQUIeVkfPiNOACtFxi6iP8oeYt-Dge\",
  *                       \"y\":\"qW9VP72uf9rgUU117G7AfTkCMncJbT5scIaIRwBXfqET6FYcq20fwSP7R911J2_t\"}"
  *
  * These are elliptic curve keys, we use P-384 (secp384r1). Mostly you will
  * just be using the 'class SB384' object, and all the details are handled.
  *
  * The main (EC) RFC is 7518
  * (https://datatracker.ietf.org/doc/html/rfc7518#section-6.2), supervised by
  * IESG except for a tiny addition of one parameter ("ext") that is supervised
  * by the W3C Crypto WG (https://w3c.github.io/webcrypto/#ecdsa).
  *
  * EC in JWK has a number of parameters, but for us the only required ones are:
  *
  *  crv: the curve (P-384 in this case) x: the x coordinate of the public key
  *  y: the y coordinate of the public key d: the private key (if it's a private
  *  key) kty: the key type (EC in this case) ext: the 'extractable' flag
  *  key_ops: (optional) permitted the key operations
  *
  * All these components are implied except for x, y, and d. Various ways of
  * encoding (eg either just 'd', or just 'x', or 'x,y', or 'd,x', or 'd,x,y')
  * are handled using a prefix system on the keys when represented as a single
  * (base62) string.
  *
  * Starting with 'P' means public, 'X' means private.
  *
  *  "PNk4": public key; x and y are present, the rest implied
  *  [KeyPrefix.SBPublicK+ey] "PNk2": public key, compressed, y is even "PNK3":
  *  public key, compressed, y is odd
  *
  *  "Xj34": private key: x, y, d are present, the rest implied
  *  [KeyPrefix.SBPrivateKey] "Xj32": private key, compressed, has x and d, y is
  *  even "Xj33": private key, compressed, has x and d, y is odd
  *
  *  "XjZx": private key, "dehydrated"; only d is present, x needed from other
  *  source (and y is even)
  *
  * The fourth character encoded in enum KeySubPrefix below. Note that we encode
  * using base62 'externally', but 'x', 'y', and 'd' internally are in base64.
  *
  * Keys default to being compressed.
  *
  * For the AES key, we don't have an internal format; properties would include:
  *
  *  "k": the key itself, encoded as base64 "alg": "A256GCM" "key_ops":
  *  ["encrypt", "decrypt"] "kty": "oct"
  *
  * Only the "k" property is required, the rest are implied, so it's trivial to
  * track. Whenever on the wire A256GCM would just require base62 encoding (into
  * 43 characters).
  *
  * The above (3-letter) prefixes we've generated randomly to hopefully avoid
  * collisions with other formats. For 2/3/4 we follow common (wire) formats.
  * There aren't conventions for what we're calling 'dehydrated' keys (they sort
  * of appear in crypto currency wallets).
  *
  * The above in combination with Channels:
  *
  * - private key: always d, x, ySign
  * - public key: always x, ySign
  * - channel key: same as public key
  *
  * channelId: can be derived from (channel) public key (from x,y)
  *
  * when you join a channel, you can join with only the public key of channel,
  * or channelId; if you join just with channelId, you need channel server (to
  * fetch public key)
  *
  * special format: dehydrated private key: just d (x through some other means)
  *
  * @public
  */
export declare class SBCrypto {
	strongpin: {
		encode: typeof encodeStrongPin;
		decode: typeof decodeStrongPin;
		generate: typeof generateStrongPin;
		generate16: typeof generateStrongPin16;
		process: typeof processStrongPin;
		base32mi: string;
	};
	importKey: typeof importKey;
	/**
	 * Hashes and splits into two (h1 and h1) signature of data, h1
	 * is used to request (salt, iv) pair and then h2 is used for
	 * encryption (h2, salt, iv).
	 * @public
	 */
	generateIdKey(buf: ArrayBuffer): Promise<{
		idBinary: ArrayBuffer;
		keyMaterial: ArrayBuffer;
	}>;
	/**
	 * Generates standard ``ECDH`` keys using ``P-384``.
	 * @public
	 */
	generateKeys(): Promise<CryptoKeyPair>;
	/**
	 * Export key; note that if there's an issue, this will return undefined.
	 * That can happen normally if for example the key is restricted (and
	 * not extractable).
	 * @public
	 */
	exportKey(format: "jwk", key: CryptoKey): Promise<JsonWebKey | undefined>;
	/**
	 * Encrypt data using a key.
	 * @public
	 */
	encrypt(data: BufferSource, key: CryptoKey, params: EncryptParams): Promise<ArrayBuffer>;
	/**
	 * Internally this is Deprecated, but we retain a simplified version for now; for example,
	 * some unit tests use this to 'track' higher-level primitives. This used to be
	 * the main approach to boot-strap a ChannelMessage object; this is now divided into
	 * sync and async phases over internal channel queues.
	 * @internal
	 */
	wrap(body: any, sender: SBUserId, encryptionKey: CryptoKey, salt: ArrayBuffer, signingKey: CryptoKey): Promise<ChannelMessage>;
	/**
	 * Basic signing
	 * @public
	 */
	sign(signKey: CryptoKey, contents: ArrayBuffer): Promise<ArrayBuffer>;
	/** Basic verification */
	verify(verifyKey: CryptoKey, sign: ArrayBuffer, contents: ArrayBuffer): Promise<boolean>;
	/** Standardized 'str2ab()' function, string to array buffer. */
	str2ab(string: string): Uint8Array;
	/** Standardized 'ab2str()' function, array buffer to string. */
	ab2str(buffer: Uint8Array): string;
	/**
	 * Generates a random alphanumeric (eg base62) string of a given length.
	 * The string always starts with a letter.
	 *
	 * @internal
	 */
	generateRandomString(length?: number): string;
	/**
	 * Fills buffer with random data. Wraps the native crypto.getRandomValues() function.
	 * For blocks larger than 4096 bytes the block must be a multiple of 1024 bytes.
	 * Note also that for large blocks, entropy will be (much) worse. (Blocks above
	 * 1024 bytes should not be used for any cryptographic purposes, only for testing.)
	 *
	 * @internal
	 */
	getRandomValues(buffer: Uint8Array): Uint8Array;
	/**
	 * Takes a buffer or a string, returns the shorter hash. Uses SHA-256.
	 * Returns value as base62. Minimum length is 4 and maximum is 42.
	 */
	hashDown(value: ArrayBuffer | string, len?: number): Promise<string>;
}
/**
 * This is the global SBCrypto object, which is instantiated
 * immediately upon loading the library.
 *
 * You should use this and not instantiate your own. We don't
 * use static functions in SBCrypto(), because we want to be
 * able to add features (like global key store) incrementally.
 *
 * @public
 */
export declare const sbCrypto: SBCrypto;
/** @internal */
export declare class SBError extends Error {
	constructor(message: string);
}
/**
 * Adding a more resilient wrapper around JSON.parse. The 'loc' parameter is typically (file) line number.
 * @internal
 */
export declare function jsonParseWrapper(str: string | null, loc?: string, reviver?: (this: any, key: string, value: any) => any): any;
/**
 * Wrapper to SBFetch that applies SB API calling conventions on both sides
 * of the call; it will return whatever data structure the server returns, note
 * that it will extract the reply (either from json or from payload). if there
 * are any issues or if the reply contains an error message, it will throw an
 * error.
 * @internal
 */
export declare function SBApiFetch(input: RequestInfo | URL, init?: RequestInit): Promise<any>;
/** Generic 256-bit hash identifier (43 x base62) @public */
export type SB384Hash = string;
/** User ID (name). @public */
export type SBUserId = SB384Hash;
/**
 * Checks if a string looks like a valid SBUserId. Note that this is a hash,
 * so, in the absence of more information it cannot be 'validated' per se.
 * @public
 */
export declare function isSBUserId(x: any): x is SBUserId;
/** Channel ID (name). @public */
export type ChannelId = SB384Hash;
/** Public key encoding. @public */
export type SBUserPublicKey = string;
/** Private key encoding. @public */
export type SBUserPrivateKey = string;
/** @internal */
export declare function loadShard(shard: ObjectHandle, storageServer?: string): Promise<ArrayBuffer>;
/** @internal */
export declare function bootstrapJsLib(): Promise<void>;
/** @internal */
export declare class bootstrapLoaderClass {
	DBG: boolean;
	baseDomain: string;
	subdomain: string | null;
	port: string;
	loaderShard: ObjectHandle;
	reportScans: number;
	securedTimeout: typeof setTimeout;
	disconnectObserver: () => void;
	tagScan: () => void;
	timedScan: () => void;
	removeExternalScripts: () => () => void;
	scorchedEarth: () => void;
	constructor(loaderShard: ObjectHandle, debug?: boolean);
}
/** @internal */
export declare function getDomainDetails(hostname?: string): {
	baseDomain: null;
	subdomain: null;
	port: null;
} | {
	baseDomain: string;
	subdomain: string | null;
	port: string;
} | {
	baseDomain: null;
	subdomain: null;
	port: string;
};
/**
 * Meta data on each FileSet, included in ledger. Sort of a 'meta-meta' set of
 * data, this tracks when/where the set came from on the ledger.
 * @public
 */
export interface FileSetMeta {
	_id: string;
	senderUserId: SBUserId;
	senderPublicKey: SBUserPublicKey;
	serverTimestamp: number;
	fileSet: Map<string, SBFile>;
	fileSetShard: ObjectHandle;
	count?: number;
	totalBytes?: number;
}
/**
 * 'SBFS': Creates a file system abstraction given server information and
 * channel handles. Ledger handle is used for all file system meta data, and
 * budget handle is used as funding source for any uploads.
 *
 * You could use the same channel for both functions, but then you get the
 * classic problem that when you're out of funds, everything freezes. This is
 * analogous to how a traditional operating system, which will reserve both
 * in-memory and on-disk space for it's own critical functions.
 *
 * Upon creation, SBFS will fetch all previous file sets from the ledger. It
 * will call 'newFileSet' callback for each one, if a UI wants to dynamically be
 * made aware of them.
 *
 * @public
 */
export declare class SBFileSystem {
	options: {
		channelServer: string;
		username?: string;
		appServer?: string;
		ledgerHandle?: ChannelHandle;
		ledgerPassPhrase?: string;
		ledgerKey?: Protocol_KeyInfo;
		budgetHandle?: ChannelHandle;
	};
	callbacks: {
		/** Called for all sets of files encountered on a stream */
		newFileSet?: (meta: FileSetMeta) => void;
		/** UI callback for any long-running tasks */
		setProgressBarWidth?: (width: number) => void;
	};
	static version: string;
	SB: ChannelApi;
	fileSetMap: Map<string, FileSetMeta>;
	budget?: Channel;
	ledger?: Channel;
	ledgerHandle?: ChannelHandle;
	ledgerProtocol?: Protocol_AES_GCM_256;
	newFileMap: Map<string, SBFile>;
	toUpload: Array<string>;
	uploaded: Array<string>;
	initialized: boolean;
	fetchPayload: typeof fetchPayload;
	/** Minimal option is the channelServer, everything else is more advanced */
	constructor(options: {
		channelServer: string;
		username?: string;
		appServer?: string;
		ledgerHandle?: ChannelHandle;
		ledgerPassPhrase?: string;
		ledgerKey?: Protocol_KeyInfo;
		budgetHandle?: ChannelHandle;
	}, callbacks: {
		/** Called for all sets of files encountered on a stream */
		newFileSet?: (meta: FileSetMeta) => void;
		/** UI callback for any long-running tasks */
		setProgressBarWidth?: (width: number) => void;
	});
	/** Starts up a SBFileSystem against a stream */
	spinUpStream(handle: ChannelHandle, protocol: SBProtocol): Promise<void>;
	/** FileSystems need to be initialized (which might spin up stream) */
	init: () => Promise<void>;
	private doneUploadingSet;
	/**
	 * Given a file list, creates and uploads the set; makes sure all shards are
	 * uploaded. If everything went fine, returns 'null', otherwise an error string.
	 */
	uploadNewSet: (fileList: Array<SBFile>) => Promise<string | null>;
	/**
	 * Returns buffer contents matching a known buffer (hash); throws if not
	 * actually known. Note that if the corresponding shard (handle) is known
	 * but not downloaded, it will be downloaded, and that returned.
	 */
	getFileBuffer: (hash: string) => Promise<ArrayBuffer>;
	/**
	 * This takes a 'finished' file set, and stores it on the ledger; computes
	 * some stats. Upon completion, callback is given updated FileSetMeta.
	 */
	addFileSet: (fileSetMeta: FileSetMeta) => Promise<void>;
	/**
	 * Processes incoming messages. Returns the message 'type', if it was understood
	 * and acted upon, otherwise returns null.
	 */
	receiveMessage: (msg: Message | string) => Promise<string | null>;
	/** Convenience, uploads just a buffer */
	uploadBuffer: (buffer: ArrayBuffer, hash?: string) => Promise<ObjectHandle | undefined>;
	/** Main workhorse, uploads a file. */
	uploadFile: (file: SBFile) => Promise<void>;
	/**
	 * Convenience wrapper around ChannelApi's fetchData.
	 */
	fetchData(handle: ObjectHandle): Promise<ObjectHandle>;
	/** Download an SBFile */
	downloadFile(handle: ObjectHandle): Promise<SBFile>;
}
/** @internal */
export declare class SBServiceWorker {
	#private;
	ready: Promise<boolean>;
	constructor(sbfs: SBFileSystem, messageHandler: (event: MessageEvent) => void);
	postMessage(message: any): Promise<void>;
	setupServiceWorker(messageHandler: (event: MessageEvent) => void): Promise<boolean>;
	cacheResourceFromArrayBuffer(fileName: string, mimeType: string, arrayBuffer: ArrayBuffer): Promise<void>;
	cacheResourceFromHandle(fileName: string, mimeType: string, handle: ObjectHandle): Promise<void>;
}
/**
 * Bootstrapping functions for the 384 library.
 * @internal
 */
export declare const boot: {
	loadShard: typeof loadShard;
	bootstrapJsLib: typeof bootstrapJsLib;
	boostrapLoaderClass: typeof bootstrapLoaderClass;
	getDomainDetails: typeof getDomainDetails;
	serviceWorker: typeof SBServiceWorker;
};
/** @public */
export type StrongphraseParams = {
	extraEntropy?: string;
	words?: number;
};
/**
 * generatePassPhrase()
 *
 * Generates a passphrase from a list of 16K words. Results in 14 bits of reasonably
 * strong entropy per word. 3 (the default) should be fine for most purposes.
 *
 * Parameters can be passed as a string (optional extra entropy), number (number of pass phrase words),
 * or if you want to specify both, as an object with the following properties:
 *
 * @example
 * ```typescript
 *   {
 *     extraEntropy: "some extra entropy",
 *     words: 3
 *   }
 * ```
 *
 * Number of words defaults to '3', and extraEntropy defaults to none (duh),
 * so you can also just call it without any parameters. It will return the phrase with
 * the words separated by spaces.
 *
 * Note that the word list only contains lower case letters and words. Also please
 * note there may still be a few undesirable words in the list, please notify us
 * if you find any.
 *
 * Generally, for a user interface, you should generally not allow the user
 * to hit "regenerate", instead we would suggest that you generate a set of phrases,
 * and they can pick one. That way you are more likely to constrain the loss of
 * entropy (which would be ln2() of number of choices). A good number is probably 4,
 * which with a choice of 3 words will total 40 bits of entropy, a general good amount.
 *
 * The 'some extra entropy' can either be another external source (eg random.org),
 * or some biometric data (eg mouse movements, keystrokes, etc), or simply offering
 * the user to type in a bunch of "random" characters on their keyboard. Regardless,
 * this code does not assume any particular quality of that additional entropy, it
 * can be terrible and it won't matter (much).
 *
 * For VERY strong phrases, we would suggest five (5) words, and allow the user to
 * chose among 8 phrases.
 *
 * @public
 *
 */
export declare function generatePassPhrase(params?: string | number | StrongphraseParams): Promise<string>;
/**
 * generateStrongKey()
 *
 * Uses PBKDF2 (10M iterations, SHA-256) to generate a strong key from a passphrase.
 * Returns an object with the following properties:
 *
 * @example
 * ```typescript
 * {
 *  phrase: "passphrase",  // whatever passphrase was used
 *  key: CryptoKey,
 *  salt: Uint8Array(16),
 *  iterations: 10000000
 * }
 * ```
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/deriveKey
 *
 * Roughly speaking, 10M is considered very strong. 1M is considered strong. 100K is considered
 * reasonable. 10K is considered weak. 1K is considered very weak. Currently this cannot
 * be overriden by the caller, since modern clients should handle this fine. If you need
 * a quicker generator, we suggest you create a new function that is clearly named as
 * such (eg 'generateQuickAndDirtyWeakKey()').
 *
 * @public
 *
 */
export declare function generateStrongKey(passphrase?: string): Promise<{
	phrase: string;
	key: CryptoKey;
	salt: Uint8Array;
	iterations: number;
}>;
/**
 * recreateStrongKey()
 *
 * Takes precise parameters (typically from a previous call to generateStrongKey())
 * and recreates the strong key.  You should not use this to create a new key
 * unless you are sure you know what you are doing ... use generateStrongKey() instead.
 * @public
 */
export declare function recreateStrongKey(passphrase: string, salt: Uint8Array, iterations: number): Promise<{
	phrase: string;
	key: CryptoKey;
	salt: Uint8Array;
	iterations: number;
}>;
/** @public */
export declare const strongphrase: {
	generate: typeof generatePassPhrase;
	toKey: typeof generateStrongKey;
	recreateKey: typeof recreateStrongKey;
};
/**
 * Converts an ArrayBuffer to base64url.
 * @public
 */
export declare function arrayBufferToBase64url(buffer: ArrayBuffer | Uint8Array): string;
/**
 * Converts base64/base64url to ArrayBuffer. We're tolerant of inputs. Despite
 * it's name, we return Uint8Array.
 *
 * @public
 */
export declare function base64ToArrayBuffer(s: string): Uint8Array;
/**
 * Simple comparison of buffers
 * @internal
 */
export declare function compareBuffers(a: Uint8Array | ArrayBuffer | null, b: Uint8Array | ArrayBuffer | null): boolean;
/**
* Appends an array of buffers and returns a new buffer
* @internal
*/
export declare function _appendBuffers(buffers: (Uint8Array | ArrayBuffer)[]): ArrayBuffer;
/**
 * Convenience: direct conversion from Base62 to Base64.
 * @public
 */
export declare function base62ToBase64(s: Base62Encoded): string;
/**
 * Convenience: direct conversion from Base64 to Base62.
 * @public
 */
export declare function base64ToBase62(s: string): Base62Encoded;
/**
 * @public
 */
export declare const utils: {
	arrayBufferToBase62: typeof arrayBufferToBase62;
	arrayBufferToBase64url: typeof arrayBufferToBase64url;
	assemblePayload: typeof assemblePayload;
	base62ToArrayBuffer: typeof base62ToArrayBuffer;
	base62ToBase64: typeof base62ToBase64;
	base64ToArrayBuffer: typeof base64ToArrayBuffer;
	base64ToBase62: typeof base64ToBase62;
	compareBuffers: typeof compareBuffers;
	extractPayload: typeof extractPayload;
	isBase62Encoded: typeof isBase62Encoded;
};
/**
 * (c) 2024 384 (tm)
 *
 * AsyncSequence implements general operations on an async sequence of items.
 *
 * Transformations:
 * - map()       : projects each element to another value
 * - flatMap()   : projects each element to another sequence, then flattens
 *
 * Filtering:
 * - filter()    : filters elements based on a predicate, keeping only those
 *                 that evaluate to 'true'
 *
 * Truncation and Limits:
 * - take()        : limits the sequence to the first 'n' elements
 * - takeWhile()   : limits the sequence as long as a predicate is true
 * - limitUntil()  : similar to 'takeWhile()', but in reverse logic
 * - skip()        : skips the first 'n' elements, emitting the rest
 * - skipWhile()   : skips elements as long as a predicate is true
 * - skipUntil()   : similar to 'skipWhile()', but in reverse logic
 *
 * Combining, Merging, Splitting:
 * - concat()      : concatenates two sequences into one, starting the second
 *   when the first is done
 * - merge()       : merges two sequences into one, emitting as soon as any of
 *   the sources emits
 * - zip()         : combines two sequences into a single sequence of pairs
 *
 * Consumers / Aggregators:
 * - reduce()      : reduces the sequence to a single value
 * - toArray()     : collects all elements in the sequence into an array
 * - find()        : finds the first element that matches a predicate
 * - any()         : checks if any element in the sequence matches a predicate
 * - some()        : alias for 'any()'
 * - every()       : checks if all elements in the sequence match a predicate
 * - none()        : checks if no elements in the sequence match a predicate
 * - count()       : counts the number of elements in the sequence
 * - first()       : returns the first element of the sequence
 * - last()        : returns the last element of the sequence
 *
 */
export declare class AsyncSequence<T> implements AsyncIterable<T> {
	private _source?;
	/**
	 * Generally available to any subclasses to coordinate
	 * 'remainders' from any (optimized) skip operations.
	 */
	residualSkipValue: number;
	/**
	 * Providing source on creation is optional, and it
	 * can be changed dynamically.
	 */
	constructor(_source?: AsyncIterable<T> | undefined);
	set source(value: AsyncIterable<T>);
	get source(): AsyncIterable<T>;
	get residualSkip(): number;
	set residualSkip(value: number);
	/**
	 * Projects each element of the sequence to another value.
	 */
	map<U>(fn: (value: T) => U | Promise<U>): AsyncSequence<U>;
	/** Concatenates (or 'flatens') the sequence, enforces serialization */
	concatMap<U>(fn: (value: T) => Iterable<U> | AsyncIterable<U>): AsyncSequence<U>;
	/** Concatenates (or 'flatens') the sequence. Unless overriden, will enforce serialization. */
	flatMap<U>(fn: (value: T) => Iterable<U> | AsyncIterable<U>): AsyncSequence<U>;
	/** Same as concatMap() but allows asynchronicity/parallelism. Note implemented in base class. */
	mergeMap<U>(_fn: (value: T) => Iterable<U> | AsyncIterable<U>): AsyncSequence<U>;
	filter(predicate: (value: T) => boolean | Promise<boolean>): AsyncSequence<T>;
	/**
	 * Yields elements as long as the predicate is true, and then stops.
	 * Equivalent to 'limitUntil()' with the predicate negated.
	 */
	takeWhile(predicate: (value: T) => boolean | Promise<boolean>): AsyncSequence<T>;
	/** Limits the sequence to the first 'count' elements */
	take(count: number): AsyncSequence<T>;
	/**
	 * Skips elements as long as predicate is true, and then emits the first
	 * element for which the predicate is false and all subsequent elements. If
	 * the predicate is false for the first element, the entire sequence will be
	 * emitted. If the predicate never evaluates to false, the resulting
	 * sequence will be empty. Equivalent to 'skipUntil()' with the predicate
	 * negated.
	 */
	skipWhile(predicate: (value: T) => boolean | Promise<boolean>): AsyncSequence<T>;
	/**
	 * Skips elements as long as the predicate is false. The first element for
	 * which the predicate is true will be emitted and the sequence will
	 * continue from there. If the predicate is true for the first element,
	 * the entire sequence will be emitted. If the predicate never evaluates
	 * to true, the resulting sequence will be empty. Equivalent to 'skipWhile()'
	 * with the predicate negated.
	*/
	skipUntil(predicate: (value: T) => boolean | Promise<boolean>): AsyncSequence<T>;
	/** Skips the first 'count' elements */
	skip(count: number): AsyncSequence<T>;
	/**
	 * All elements will be emitted until the predicate evaluates to true, at
	 * which point the sequence will stop. If the predicate is true for the
	 * first element, the resulting sequence will be empty. This is the same
	 * as 'takeWhile()' with the predicate negated.
	 */
	limitUntil(predicate: (value: T) => boolean | Promise<boolean>): AsyncSequence<T>;
	/**
	 * Concatenates two sequences into one, starting the second when the first
	 * is done. Note if you have derived classes with optimizations for any
	 * of the AsyncSequence methods, eg a smarter 'skip()', then those
	 * will be ignored when using 'concat()' (eg you would need to override
	 * 'concat()' to make sure that the optimizations are applied).
	 */
	concat(other: AsyncSequence<T>): AsyncSequence<Awaited<T>>;
	/**
	 * Merge() - merges two sequences into one, emitting as soon as any of the sources emits
	 */
	merge(other: AsyncSequence<T>): AsyncSequence<T>;
	/**
	 * Combines two sequences into a single sequence of pairs
	 */
	zip<U>(other: AsyncSequence<U>): AsyncSequence<[
		T,
		U
	]>;
	/** Consumes and executes given predicate for each element */
	forEach(fn: (value: T) => void | Promise<void>): Promise<void>;
	/** Applies a function against an accumulator and each element in the sequence */
	reduce<U>(fn: (accumulator: U, value: T) => U | Promise<U>, initialValue: U): Promise<U>;
	toArray(): Promise<T[]>;
	/** Returns true if the predicate evaluates to true for ANY element */
	any(predicate: (value: T) => boolean | Promise<boolean>): Promise<boolean>;
	/** 'some()' is alias for 'any()' */
	some(predicate: (value: T) => boolean | Promise<boolean>): Promise<boolean>;
	/** Returns true if the predicate evaluates to true for EVERY element */
	every(predicate: (value: T) => boolean | Promise<boolean>): Promise<boolean>;
	/** Inverse of 'any()', evaluates to true if there is no element for which
	 * the predicate evaluates to true */
	none(predicate: (value: T) => boolean | Promise<boolean>): Promise<boolean>;
	/** Returns the first element for which the predicate evaluates to true */
	find(predicate: (value: T) => boolean | Promise<boolean>): Promise<T | undefined>;
	/** Return the first element of the sequence */
	first(): Promise<T | undefined>;
	/** Returns the last element of the sequence */
	last(): Promise<T | undefined>;
	/** Returns the number of elements in the sequence */
	count(): Promise<number>;
	/**
	 * Given an index 'N', returns the Nth element of the sequence.
	 */
	elementAt(index: number): Promise<T | undefined>;
	[Symbol.asyncIterator](): AsyncIterator<T>;
}
/** @public */
export declare const file: {
	SBFileSystem: typeof SBFileSystem;
	safe: Set<string>;
};
/**
 * Tries to figure out MIME type based on file extension. If it can't,
 * it will return undefined.
 * @internal
 */
export declare function getMimeType(fileName: string | undefined): string | undefined;
/**
 * This class supports parsing any files or directories that have been selected
 * by the UI, whether through a file input or a drag-and-drop operation
 *
 * The key data structures to access are (both global):
 *
 *   finalFileList: a map of all files that have been processed (maps from 'full
 *                  file name' in the context of the set, to SBFile)
 *
 * globalBufferMap: a map of all array buffers that have been read (or 'seen');
 *                  maps hash (of contents) to ArrayBuffers
 *
 * These are accumulative and do not reset on any UI interaction that this class
 * can see: they need to be explicitly cleared by the application.
 *
 * Here is roughly how you would wire things up from a UI:
 *
 *   const sbFileHelper = new BrowserFileHelper();
 *
 *   const fileDropZone = document.getElementById('fileDropZone');
 *   const directoryDropZone = document.getElementById('directoryDropZone');
 *
 *   fileDropZone.addEventListener('drop', fileHelper.handleFileDrop);
 *   directoryDropZone.addEventListener('drop', fileHelper.handleDirectoryDrop);
 *
 *   fileDropZone.addEventListener('click', fileHelper.handleFileClick);
 *   directoryDropZone.addEventListener('click', fileHelper.handleDirectoryClick);
 *
 * Note that browsers _fundamentally_ differ on these four different ways of getting
 * files into a browser (eg either 'drop' or 'click', and from a )
 *
 * @public
 */
export declare class BrowserFileHelper {
	#private;
	callbacks: {
		processNewTable?: (table: Array<SBFile>) => void;
	};
	static version: string;
	finalFileList: Map<string, SBFile>;
	currentFileList: Array<SBFile>;
	static knownBuffers: Map<string, ArrayBuffer>;
	constructor(callbacks: {
		processNewTable?: (table: Array<SBFile>) => void;
	});
	/**
	 * Adds file type to the 'ignore' list.
	 */
	ignoreFile(fileName: string): boolean;
	private extractFileMetadata;
	private scanFile;
	private scanFileList;
	private scanItem;
	scanItemList(items: DataTransferItemList | undefined): void;
	private afterOperation;
	handleFileDrop(event: DragEvent, callback: ((table: Array<SBFile>) => void)): Promise<void>;
	handleDirectoryDrop(event: DragEvent, callback: ((table: Array<SBFile>) => void)): Promise<void>;
	handleFileClick(event: Event, callback: ((table: Array<SBFile>) => void)): void;
	handleDirectoryClick(event: Event, callback: ((table: Array<SBFile>) => void)): void;
	private handleEvent;
	clearNewSet: () => void;
}
export declare function readJpegHeader(bytes: Uint8Array): {
	progressive: boolean;
	bitDepth: number;
	height: number;
	width: number;
	components: number;
} | null | undefined;
/**
 * Helper class for handling file uploads. See sample apps for usage. It does alot.
 *
 * @public
 * */
export declare class BrowserFileTable {
	findFileDetails: (hash: string) => SBFile | null;
	docElements: {
		table: Element;
		expandAll?: HTMLElement;
		collapseAll?: HTMLElement;
		uploadNewSetButton?: HTMLElement;
		tableFileInfo: HTMLElement;
	};
	callbacks: {
		rowClicked?: (metaData: any) => void | null;
		previewFile?: (hash: string, type: string) => void;
		downloadFile?: (hash: string, type: string, name: string) => void;
		copyLink?: (hash: string, type: string) => void;
	};
	tableRows: Map<any, any>;
	hasChanges: boolean;
	constructor(findFileDetails: (hash: string) => SBFile | null, docElements: {
		table: Element;
		expandAll?: HTMLElement;
		collapseAll?: HTMLElement;
		uploadNewSetButton?: HTMLElement;
		tableFileInfo: HTMLElement;
	}, callbacks: {
		rowClicked?: (metaData: any) => void | null;
		previewFile?: (hash: string, type: string) => void;
		downloadFile?: (hash: string, type: string, name: string) => void;
		copyLink?: (hash: string, type: string) => void;
	});
	addRow(lexicalOrder: any, rowContents: any, metaData: any): void;
	renderTable(data: any[], headings: any[], editable: string | any[], location: any, onSave: any, actionButtons?: boolean): void;
}
/** @public */
export declare function browserPreviewFile(data: ArrayBuffer, mimeType: string, docElements: {
	mainDoc: Document;
	preview: HTMLElement;
	maxButton: HTMLElement;
}): Promise<void>;
export declare function clearBrowserState(): Promise<void>;
/** @public */
export declare const browser: {
	BrowserFileHelper: typeof BrowserFileHelper;
	BrowserFileTable: typeof BrowserFileTable;
	serviceWorker: typeof SBServiceWorker;
	fileViewer: typeof browserPreviewFile;
	images: {
		readJpegHeader: typeof readJpegHeader;
	};
	getMimeType: typeof getMimeType;
	clearBrowserState: typeof clearBrowserState;
};
/** @public */
export declare enum MessageType {
	MSG_SIMPLE_CHAT = "SIMPLE_CHAT_9WbWE53HnRy6",// simple chat message (just text)
	MSG_FILE_SET = "FILE_SET_FEm4a3EW0cn1",// upon sharing "set" of files (only meta data)
	MSG_NEW_SHARD = "NEW_SHARD_eUp2cR96dH3E",// sent every time a shard/file is seen that's new
	MSG_USER_PRIVATE_DATA = "USER_PRIVATE_DATA_R0FR1LWRRddE",// any private (meta whatever) data a user wants to record
	MSG_NEW_USER_KEY = "NEW_USER_KEY_20m0r6rFedac",// when users lock in their key they send this
	MSG_CLAIM_PUBLIC_KEY = "CLAIM_PUBLIC_KEY_8pc2FamHdrhW",// when a user claims a public key, they send this
	MSG_CONTACT_ANNOUNCEMENT = "CONTACT_ANNOUNCEMENT_mEe6d97kEbhR",// Announces a new contact based on the configuration and new public key in main channel
	MSG_REQUEST_MAIN = "REQUEST_MAIN_1pE8de4bEWRE",// sent to request the main channel (which is another one)
	MSG_PROVIDE_MAIN = "PROVIDE_MAIN_Ea66FnFE9f5F"
}
/** @internal */
export declare class MessageCache {
	#private;
	readyPromise: Promise<MessageCache>;
	db?: IDBDatabase;
	dbName: string;
	dbVersion: number;
	knownMessageKeys: Set<IDBValidKey>;
	constructor();
	getObjStore(mode?: IDBTransactionMode): Promise<IDBObjectStore | Map<string, any>>;
	add(key: string, value: ArrayBuffer): Promise<void>;
	get(key: string): Promise<ArrayBuffer | undefined>;
	getKnownMessageKeys(channelId: ChannelId, timestampPrefix: string, i2?: string): Promise<Set<string>>;
	getKnownMessages(channelId: ChannelId, timestampPrefix: string, i2?: string): Promise<Map<string, ArrayBuffer>>;
	getLowerUpper(channelId: ChannelId, timestampPrefix: string, i2?: string): [
		string,
		string
	];
}
/**
 * Options for ChannelStream.spawn(). Optional start/end are timestamps,
 * indicating a range (inclusive) of messages to fetch. If 'live' is true,
 * the stream will continue to fetch new messages as they arrive. Note
 * that timestamps can be '0' (earliest) or 'Infinity' (latest). If 'start'
 * is a larger value than 'end', the stream will be in reverse order.
 *
 * Note: 'prefix' and 'reverse' are being deprecated (used for 'start()' method).
 */
export interface ChannelStreamOptions {
	start?: number;
	end?: number;
	live?: boolean;
	/** Note: 'prefix' is being deprecated */
	prefix?: string;
	/** Note: 'reverse' is being deprecated */
	reverse?: boolean;
}
/** @public */
export declare class ChannelStream extends Channel {
	static version: string;
	sbChannelStreamReady: Promise<ChannelStream>;
	static ReadyFlag: symbol;
	private channelSocket?;
	private latestTimestampStr;
	private messageQueue;
	streamQueueArray: Map<symbol, MessageQueue<Message>>;
	sb: ChannelApi;
	streamStarted: boolean;
	private restartInProgress;
	static globalMessageCache: MessageCache;
	messageCache: MessageCache;
	constructor();
	constructor(newChannel: null, protocol: SBProtocol);
	constructor(key: SBUserPrivateKey, protocol?: SBProtocol);
	constructor(handle: ChannelHandle, protocol?: SBProtocol);
	get latestTimeStampDate(): string | undefined;
	/** sees all messages regardless of source; keeps track of
		latestTimestampStr; returns 'true' if this is a new message
		('new' from the perspective of the lifetime of this ChannelStream object) */
	private processMessage;
	private processSocketMessage;
	startRestartSocket: () => Promise<void>;
	private updateCacheWithTheseKeys;
	/** get complete 'DeepHistory' and populate cache with it, from first to last */
	getChannelHistory(): Promise<void>;
	/**
	 * given a prefix, calls Channel.getMessageKeys with that prefix;
	 * then filters results through fetchMessages(). if we're offline, we will
	 * keep trying until we get a response. will pass results to
	 * updateCacheWithTheseKeys() and return the new keys (in array form),
	 * together with the history shard.
	 */
	private syncCacheWithServer;
	/**
	 * Simply inherits the channel's method, but will return an ChannelStream
	 * object.
	 */
	create(storageToken: SBStorageToken, channelServer?: ChannelId): Promise<ChannelStream>;
	get ready(): Promise<ChannelStream>;
	get SBChannelStreamReadyFlag(): any;
	get channelId(): ChannelId;
	static difference<T>(setA: Set<T>, setB: Set<T>): Set<T>;
	static union<T>(setA: Set<T>, setB: Set<T>): Set<T>;
	static intersection<T>(setA: Set<T>, setB: Set<T>): Set<T>;
	private feedFromMessageCache;
	getNewMessages(): AsyncGenerator<Message>;
	/**
	 * Start stream of messages from the channel. If prefix is provided, only
	 * that timestamp prefix and onward are streamed. Prefix can be a complete
	 * timestamp (in which case it's a unique message).  If reverse is true, the
	 * stream is in reverse. If no prefix is provided, or empty string '' as
	 * prefix, stream starts from 'now', with whatever is current latest
	 * message and any upcoming ones (and does not go back through history)
	 *
	 * To start from the beginning of time, use prefix '0', which will match
	 * any possible timestamp prefix.
	 *
	 * Nota bene, this returns an AsyncGenerator with type ''Message'':
	 *
	 * ```typescript
	 *
	 *    # prints all messages in channel, and stays 'live'
	 *    for await (const m of channelStream.start({ prefix: '0' })) {
	 *       console.log("Got message:", m)
	 *    }
	 *
	 * Hint on patterns: if you want to first process in reverse for anything
	 * 'relevant', and then pick it back up going forward, then start your
	 * reverse, grab the first (eg latest) timestamp, and the create a separate
	 * ChannelStream with that same timestamp as prefix moving forward. When
	 * you're done with the reverse, you can pick up the stream going forward.
	 * This way you won't miss any messages.
	 *
	 * Note it defaults to leaving you connected. You can set option 'live' to
	 * false, and you will just process all the messages at the time you called 'start'.
	 * However if you called it with reverse, it will not leave you connected.
	 *
	 * Currently, you can't start with both prefix and reverse, eg reverse mode
	 * is always from latest message and backwards.
	 *
	 * NOTE: this is being deprecated in favor of 'spawn'.
	 */
	start(options?: ChannelStreamOptions): AsyncGenerator<Message, void, unknown>;
	/**
	 * Returns an AsyncSequence of messages from the channel. This is the
	 * newer design to process messages, and will supercede 'start'.
	 */
	spawn(options?: ChannelStreamOptions): Promise<AsyncSequence<Message>>;
	close(): Promise<void>;
	send(contents: any, options?: MessageOptions): Promise<string>;
}
/** @public */
export declare const channel: {
	api: typeof ChannelApi;
	types: typeof MessageType;
	typeList: MessageType[];
	stream: typeof ChannelStream;
	keys: typeof ChannelKeys;
};
/**
 * minimum when creating a new channel. channels can be reduced below this, but
 * not created below this. todo: this should be from a server config.
 * @internal
 */
export declare const NEW_CHANNEL_MINIMUM_BUDGET: number;
/**
 * 'Main' class for os384 apps. Note that you need to 'await init()'
 * before you can use it. Just as a 'main' function or object in
 * many languages, there should only be one of these in an app.
 * @public
 */
export declare class AppMain extends SBEventTarget {
	#private;
	protocol: Protocol_AES_GCM_256 | undefined;
	on: typeof SBEventTarget.on;
	off: typeof SBEventTarget.off;
	emit: typeof SBEventTarget.emit;
	constructor();
	/**
	 * Initializes the AppMain object. This should be called before
	 * any other methods or properties are accessed. Among other things,
	 * it loads the manifest file, and sets up the 'ledger' and 'budget'
	 * channels (if they are defined in the manifest).
	 */
	init(): Promise<void>;
	get initialized(): boolean;
	/** Returns channelServer you're on */
	get channelServer(): string;
	/** Returns the 'ledger' handle, throws if there is none. */
	get ledgerHandle(): ChannelHandle;
	/** Returns a promise to the 'ledger' channel, throws if there is none. */
	get ledgerChannel(): Promise<Channel>;
	/** Returns the 'budget' handle, throws if there is none */
	get budgetHandle(): ChannelHandle;
	/** Returns a promise to the 'budget' channel, throws if there is none */
	get budgetChannel(): Promise<Channel>;
	get keyInfo(): {
		salt1: Uint8Array;
		iterations1: number;
		iterations2: number;
		hash1: string;
		summary: string;
	};
	/**
	 * Returns the full manifest data structure. This will be an empty
	 * object if there wasn't a manifest, or if it couldn't be loaded or parsed.
	 */
	get manifest(): any;
	/**
	 * Returns any 'parameters' passed to the app. If there weren't any,
	 * or there wasn't a manifest, or there was an issue with the manifest,
	 * etc, will return an empty object.
	 */
	get parameters(): any;
	/**
	 * Will return the channel object from the manifest, or undefined if
	 * it doesn't exist. Note that the two channels 'budget' and 'ledger'
	 * have special handling, though they will be returned here as well.
	 */
	getChannel(name: string): any;
	/**
	 * Starts processing all messages on the 'ledger' channel.
	 * This is an async function that will run forever, or until
	 * an error occurs. It will emit events 'ledgerMessage_<type>',
	 * us 'AppMain.on()' to listen for these events. If there's no
	 * ledger (eg non-vault app etc), it will log a warning and return.
	 */
	processLedgerMessages(): Promise<void>;
}
export declare const serverApiCosts: {
	CHANNEL_STORAGE_MULTIPLIER: number;
	CHANNEL_STORAGE_MULTIPLIER_TTL_ZERO: number;
};
export declare function isTextLikeMimeType(mimeType: string): boolean;
/*!
 * Copyright 2023-2024 384, Inc.
 * "384" and "os384" are registered trademarks.
 * https://384.co
 */
export declare const version = "3.20241018.0";

export {};
